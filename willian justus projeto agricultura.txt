import streamlit as st
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.model_selection import train_test_split
from sklearn.ensemble import GradientBoostingRegressor, RandomForestRegressor
from sklearn.linear_model import LinearRegression # Added for model comparison
from sklearn.metrics import mean_squared_error, r2_score
from prophet import Prophet
from scipy.optimize import minimize
import warnings
import os
import base64 # To enable download button

# Suprimir warnings para uma saída mais limpa no Streamlit
warnings.filterwarnings('ignore')
# Configurar estilo do matplotlib
plt.style.use('seaborn-v0_8-whitegrid')

# --- DEFINIÇÃO DAS FUNÇÕES DO PROJETO AVANÇADO (Adaptadas para Streamlit) ---

# Helper function para o modelo de produção na otimização
def producao_por_ha_modelo(n_total, p_total, k_total, agua_total, necessidades_cultura):
    """
    Modelo SIMPLIFICADO de produção por hectare baseado na saturação de insumos.
    Este é um modelo conceitual para fins de otimização DEMOSTRATIVA.
    Um modelo real exigiria calibração com dados de campo.
    """
    agua_necessaria_min_ha = necessidades_cultura.get('agua', 0)
    n_necessario_min_ha = necessidades_cultura.get('nitrogenio', 0)
    p_necessario_min_ha = necessidades_cultura.get('fosforo', 0)
    k_necessario_min_ha = necessidades_cultura.get('potassio', 0)

    prod_base = 2000 # Produção base por ha (sem insumos ótimos no modelo)
    # Respostas simuladas com saturação (usando tanh)
    # Resposta > 0 apenas se total > minimo necessario
    resp_n = np.tanh(max(0, n_total - n_necessario_min_ha) / 20) * 500
    resp_p = np.tanh(max(0, p_total - p_necessario_min_ha) / 10) * 400
    resp_k = np.tanh(max(0, k_total - k_necessario_min_ha) / 15) * 300
    resp_agua = np.tanh(max(0, agua_total - agua_necessaria_min_ha) / 50) * 600


    # Combinação com fator limitante (simplificado)
    # A produção extra é limitada pelo insumo mais deficiente *acima* do mínimo necessário.
    # A 'suficiência relativa' acima do mínimo necessário, normalizada.
    # Usamos um pequeno valor epsilon para evitar divisão por zero ou log(0) se min_nec for 0
    epsilon = 1e-9

    suff_n_rel = max(0, (n_total - n_necessario_min_ha)) / (max(epsilon, 200 - n_necessario_min_ha)) # Assume max response reached around 200 above min
    suff_p_rel = max(0, (p_total - p_necessario_min_ha)) / (max(epsilon, 100 - p_necessario_min_ha)) # Assume max response reached around 100 above min
    suff_k_rel = max(0, (k_total - k_necessario_min_ha)) / (max(epsilon, 150 - k_necessario_min_ha)) # Assume max response reached around 150 above min
    suff_agua_rel = max(0, (agua_total - agua_necessaria_min_ha)) / (max(epsilon, 400 - agua_necessaria_min_ha)) # Assume max response reached around 400 above min

    # Ensure relative sufficiency is not > 1 if inputs exceed model range
    suff_n_rel = min(1.0, suff_n_rel)
    suff_p_rel = min(1.0, suff_p_rel)
    suff_k_rel = min(1.0, suff_k_rel)
    suff_agua_rel = min(1.0, suff_agua_rel)


    # O fator limitante é o mínimo da suficiência relativa, mas apenas se *todos* os insumos estiverem acima do mínimo necessário
    if n_total >= n_necessario_min_ha and p_total >= p_necessario_min_ha and k_total >= k_necessario_min_ha and agua_total >= agua_necessaria_min_ha:
         limiting_factor = min(suff_n_rel, suff_p_rel, suff_k_rel, suff_agua_rel)
    else:
         # Se algum insumo total não atinge o mínimo necessário, a produção base é impactada
         # Um fator de redução baseado em quão longe do mínimo o mais deficiente está
         min_needed_factors = [n_necessario_min_ha, p_necessario_min_ha, k_necessario_min_ha, agua_necessaria_min_ha]
         total_levels = [n_total, p_total, k_total, agua_total]
         # Calculate the ratio of total level to minimum needed for those below the minimum
         ratios_below_min = [total_levels[i] / min_needed_factors[i] for i in range(4) if total_levels[i] < min_needed_factors[i] and min_needed_factors[i] > 0]

         if ratios_below_min:
              reduction_factor = min(ratios_below_min) # The most deficient factor determines the reduction
              return prod_base * reduction_factor # Production is reduced proportionally from base if below minimums
         else:
              limiting_factor = 0 # Should not happen if the first condition is false, but for safety


    # O ganho é aplicado apenas se todos os mínimos forem atingidos e há "suficiência extra"
    # A produção total é base + ganho modulado pelo fator limitante
    # Total potential gain if all were optimal (using the tanh max responses)
    potential_gain = 500 + 400 + 300 + 600

    # O ganho real é o ganho potencial * o fator limitante (que agora reflete a suficiência acima do mínimo)
    actual_gain = potential_gain * limiting_factor

    producao_ha_estimada = prod_base + actual_gain


    return max(prod_base * 0.1, producao_ha_estimada) # Produção não cai abaixo de um mínimo severo (ex: 10% da base)


# Helper function to create download link
def download_link(data, filename, text):
    b64 = base64.b64encode(data.encode()).decode()
    href = f'<a href="data:file/csv;base64,{b64}" download="{filename}">{text}</a>'
    return href


# 1. Análise e Previsão de Safras (com Modelos ML)
def analise_previsao_safras_avancado(dados, cultura, features, categorical_features, target, model_name):
    """
    Realiza análise e previsão de safra para uma cultura usando um modelo ML selecionado.
    Adaptada para Streamlit (usa st.write e st.pyplot).
    """
    st.subheader(f"Resultados da Análise de Safra para a cultura: {cultura}")

    dados_cultura = dados[dados['Cultura'] == cultura].copy()

    if dados_cultura.empty:
        st.warning(f"Não há dados para a cultura '{cultura}'.")
        return
    if len(dados_cultura) < 10:
         st.info(f"Dados limitados para a cultura '{cultura}' ({len(dados_cultura)} amostras). A precisão do modelo pode ser limitada.")


    # Seleciona features que realmente existem no DataFrame
    features_num = [f for f in features if f in dados_cultura.columns]
    features_cat = [f for f in categorical_features if f in dados_cultura.columns]
    features_disponiveis = features_num + features_cat

    if target not in dados_cultura.columns:
         st.error(f"A coluna target '{target}' não foi encontrada no DataFrame. Não é possível treinar o modelo.")
         return
    if not features_disponiveis:
         st.warning("Nenhuma das features selecionadas foi encontrada no DataFrame. O modelo não pode ser treinado.")
         return

    X = dados_cultura[features_disponiveis].copy() # Usar copy para evitar SettingWithCopyWarning
    y = dados_cultura[target].copy()

    # Trata variáveis categóricas (One-Hot Encoding)
    if features_cat:
        cat_cols_exist = [col for col in features_cat if col in X.columns]
        if cat_cols_exist:
            X = pd.get_dummies(X, columns=cat_cols_exist, drop_first=True)
        else:
            st.info("Nenhuma das colunas categóricas selecionadas foi encontrada nos dados desta cultura.")

    # Remove colunas de X que não são numéricas após o one-hot encoding (segurança)
    X = X.select_dtypes(include=np.number)
    if X.empty:
        st.error("DataFrame de features (X) está vazio ou não contém colunas numéricas após o pré-processamento.")
        return


    # Divide os dados
    total_samples = len(X)
    if total_samples < 2:
        st.warning(f"Dados insuficientes para modelagem ({total_samples} amostras).")
        return

    is_split = True
    # Ajusta o test_size para garantir que haja dados suficientes para treino e teste (pelo menos 1 em cada)
    if total_samples < 10:
        st.info(f"Poucos dados para um split robusto ({total_samples} amostras). Treinando e avaliando no conjunto completo.")
        X_train, X_test, y_train, y_test = X, X, y, y # Train and test on the same set
        is_split = False
    else:
        try:
             # Ensure test set has at least 1 sample, test_size between 0.1 and 0.5
             test_size = min(0.5, max(0.1, 1 / total_samples)) # Guarantee at least 1 sample in test if possible
             if total_samples * test_size < 1: # Fallback if test_size calculation is problematic for tiny sets
                  test_size = 0.5 if total_samples >=2 else 0
             if test_size > 0:
                X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=test_size, random_state=42)
                # Re-check if split resulted in empty sets (can happen with weird splits/data)
                if X_train.empty or X_test.empty or y_train.empty or y_test.empty:
                    st.warning("Split resultou em conjuntos vazios. Treinando e avaliando no conjunto completo.")
                    X_train, X_test, y_train, y_test = X, X, y, y
                    is_split = False
             else:
                 st.warning("Não foi possível realizar o split dos dados com test_size > 0. Treinando e avaliando no conjunto completo.")
                 X_train, X_test, y_train, y_test = X, X, y, y
                 is_split = False


        except ValueError as e:
             st.warning(f"Não foi possível realizar o split dos dados: {e}. Treinando e avaliando no conjunto completo.")
             X_train, X_test, y_train, y_test = X, X, y, y
             is_split = False

    # Cria e treina o modelo selecionado
    st.write(f"Modelo selecionado: **{model_name}**")
    with st.spinner(f'Treinando modelo {model_name} para {cultura}...'):
        if model_name == 'Gradient Boosting Regressor':
            modelo = GradientBoostingRegressor(n_estimators=100, learning_rate=0.1, max_depth=3, random_state=42)
        elif model_name == 'Random Forest Regressor':
            modelo = RandomForestRegressor(n_estimators=100, random_state=42)
        elif model_name == 'Linear Regression':
             modelo = LinearRegression() # Linear regression is simpler
        else:
            st.error("Modelo ML não reconhecido.")
            return

        try:
            modelo.fit(X_train, y_train)
        except Exception as e:
             st.error(f"Erro durante o treinamento do modelo: {e}")
             st.info("Verifique se as features selecionadas são numéricas e não contêm valores infinitos.")
             return

    st.success(f'Modelo {model_name} treinado!')

    # Faz previsões
    try:
        y_pred_train = modelo.predict(X_train)
        y_pred_test = modelo.predict(X_test)
    except Exception as e:
         st.error(f"Erro durante a previsão com o modelo: {e}")
         return


    # Avalia o desempenho do modelo
    st.subheader("Métricas de Desempenho do Modelo:")
    mse_train = mean_squared_error(y_train, y_pred_train)
    r2_train = r2_score(y_train, y_pred_train)

    st.write(f"**MSE (Treinamento):** {mse_train:.2f}")
    st.write(f"**R² (Treinamento):** {r2_train:.2f}")

    if is_split:
        mse_test = mean_squared_error(y_test, y_pred_test)
        r2_test = r2_score(y_test, y_pred_test)
        st.write(f"**MSE (Teste):** {mse_test:.2f}")
        st.write(f"**R² (Teste):** {r2_test:.2f}")
    else:
         st.info("Métricas de teste calculadas no mesmo conjunto de treino devido ao tamanho dos dados. R² no treino pode ser superestimado.")


    # Exemplo de Feature Importances (para modelos baseados em árvore)
    if hasattr(modelo, 'feature_importances_'):
        st.subheader("Importância das Features (Top 5):")
        importances = pd.Series(modelo.feature_importances_, index=X_train.columns)
        st.dataframe(importances.sort_values(ascending=False).head())
    elif hasattr(modelo, 'coef_'):
         st.subheader("Coeficientes do Modelo (Linear Regression):")
         coefficients = pd.Series(modelo.coef_, index=X_train.columns)
         st.dataframe(coefficients.sort_values(ascending=False).head())


    # Visualiza os resultados (Observado vs. Previsto)
    st.subheader("Visualização dos Resultados:")
    fig1, axes = plt.subplots(1, 2 if is_split else 1, figsize=(12, 6))

    # Ensure axes is an array even if there's only one subplot
    if not is_split:
         axes = [axes]

    # Plot Treinamento
    axes[0].scatter(y_train, y_pred_train, alpha=0.6, label='Treinamento')
    # Add identity line
    lims = [min(y_train.min(), y_pred_train.min()), max(y_train.max(), y_pred_train.max())]
    axes[0].plot(lims, lims, '--k', alpha=0.7, label='Ideal')
    axes[0].set_title('Produção Observada vs. Prevista (Treinamento)')
    axes[0].set_xlabel('Produção Observada')
    axes[0].set_ylabel('Produção Prevista')
    axes[0].legend()


    # Plot Teste (if split)
    if is_split:
        axes[1].scatter(y_test, y_pred_test, alpha=0.6, color='orange', label='Teste')
        # Add identity line based on test data range
        lims_test = [min(y_test.min(), y_pred_test.min()), max(y_test.max(), y_pred_test.max())]
        axes[1].plot(lims_test, lims_test, '--k', alpha=0.7, label='Ideal')
        axes[1].set_title('Produção Observada vs. Prevista (Teste)')
        axes[1].set_xlabel('Produção Observada')
        axes[1].set_ylabel('Produção Prevista')
        axes[1].legend()


    plt.tight_layout()
    st.pyplot(fig1)
    plt.close(fig1)


    # Visualiza Resíduos
    fig2, axes = plt.subplots(1, 2 if is_split else 1, figsize=(12, 6))
    if not is_split:
         axes = [axes]

    residuos_train = y_train - y_pred_train
    axes[0].scatter(y_pred_train, residuos_train, alpha=0.6, label='Treinamento')
    axes[0].axhline(y=0, color='r', linestyle='--')
    axes[0].set_title('Resíduos vs. Valores Previstos (Treinamento)')
    axes[0].set_xlabel('Valores Previstos')
    axes[0].set_ylabel('Resíduos')
    axes[0].legend()

    if is_split:
        residuos_test = y_test - y_pred_test
        axes[1].scatter(y_pred_test, residuos_test, alpha=0.6, color='orange', label='Teste')
        axes[1].axhline(y=0, color='r', linestyle='--')
        axes[1].set_title('Resíduos vs. Valores Previstos (Teste)')
        axes[1].set_xlabel('Valores Previstos')
        axes[1].set_ylabel('Resíduos')
        axes[1].legend()

    plt.tight_layout()
    st.pyplot(fig2)
    plt.close(fig2)


# 2. Otimização do Uso de Recursos (com scipy.optimize) - Adaptada para Streamlit
def otimizacao_uso_recursos_avancado_streamlit(n_solo, p_solo, k_solo, area_ha,
                                               necessidades_cultura, custos, limites_aplicacao, preco_venda_un):
    """
    Calcula a quantidade ótima de água e fertilizantes usando otimização com scipy.optimize.
    Adaptada para Streamlit (usa st.write). Recebe valores diretos do app.
    """
    st.subheader("Resultado da Otimização do Uso de Recursos")

    if area_ha <= 0:
        st.warning("Área inválida para otimização.")
        return
    if preco_venda_un <= 0:
         st.warning("Preço de venda deve ser maior que zero para otimização de lucro.")
         return

    # Extrai necessidades mínimas (kg/ha ou unidade/ha) - Vindo de inputs do Streamlit
    agua_necessaria_min_ha = necessidades_cultura.get('agua', 0)
    n_necessario_min_ha = necessidades_cultura.get('nitrogenio', 0)
    p_necessario_min_ha = necessidades_cultura.get('fosforo', 0)
    k_necessario_min_ha = necessidades_cultura.get('potassio', 0)

    # Extrai custos por unidade - Vindo de inputs do Streamlit
    custo_agua_un = custos.get('agua', 0)
    custo_fertilizante_n_un = custos.get('nitrogenio', 0)
    custo_fertilizante_p_un = custos.get('fosforo', 0)
    custo_fertilizante_k_un = custos.get('potassio', 0)

    # Extrai limites máximos de aplicação por hectare - Vindo de inputs do Streamlit
    max_agua_ha = limites_aplicacao.get('agua', 500)
    max_n_ha = limites_aplicacao.get('nitrogenio', 200)
    max_p_ha = limites_aplicacao.get('fosforo', 150)
    max_k_ha = limites_aplicacao.get('potassio', 250)


    def calcular_custo_total_ha(agua_aplicada_ha, n_aplicado_ha, p_aplicado_ha, k_aplicado_ha):
        return (agua_aplicada_ha * custo_agua_un +
                n_aplicado_ha * custo_fertilizante_n_un +
                p_aplicado_ha * custo_fertilizante_p_un +
                k_aplicado_ha * custo_fertilizante_k_un)

    # Define a Função Objetivo (Para ser MINIMIZADA por scipy.optimize)
    # MINIMIZAMOS -Lucro = Custo Total - (Produção Total * Preço Venda)
    def objective_function(x):
        agua_aplicada_ha, n_aplicado_ha, p_aplicado_ha, k_aplicado_ha = x

        # Ensure non-negative application amounts within optimization
        agua_aplicada_ha = max(0, agua_aplicada_ha)
        n_aplicado_ha = max(0, n_aplicado_ha)
        p_aplicado_ha = max(0, p_aplicado_ha)
        k_aplicado_ha = max(0, k_aplicado_ha)


        n_total = n_solo + n_aplicado_ha
        p_total = p_solo + p_aplicado_ha
        k_total = k_solo + k_aplicado_ha
        agua_total = agua_aplicada_ha # Assuming 'agua_total' in model refers to applied water


        producao_ha_est = producao_por_ha_modelo(n_total, p_total, k_total, agua_total, necessidades_cultura)
        producao_total_area = producao_ha_est * area_ha

        custo_total_area = calcular_custo_total_ha(agua_aplicada_ha, n_aplicado_ha, p_aplicado_ha, k_aplicado_ha) * area_ha

        lucro = (producao_total_area * preco_venda_un) - custo_total_area

        return -lucro # Minimize negative lucro

    # --- Define as Restrições (insumos totais >= mínimo necessário) ---
    # Constraints are defined such that constraint_value >= 0 for feasible solutions.
    def constraint_n(x):
        agua_aplicada_ha, n_aplicado_ha, p_aplicado_ha, k_aplicado_ha = x
        return (n_solo + n_aplicado_ha) - n_necessario_min_ha

    def constraint_p(x):
        agua_aplicada_ha, n_aplicado_ha, p_aplicado_ha, k_aplicado_ha = x
        return (p_solo + p_aplicado_ha) - p_necessario_min_ha

    def constraint_k(x):
        agua_aplicada_ha, n_aplicado_ha, p_aplicado_ha, k_aplicado_ha = x
        return (k_solo + k_aplicado_ha) - k_necessario_min_ha

    def constraint_agua(x):
        agua_aplicada_ha, n_aplicado_ha, p_aplicado_ha, k_aplicado_ha = x
        return agua_aplicada_ha - agua_necessaria_min_ha # Constraint on *applied* water >= minimum needed

    constraints = [
        {'type': 'ineq', 'fun': constraint_n},
        {'type': 'ineq', 'fun': constraint_p},
        {'type': 'ineq', 'fun': constraint_k},
        {'type': 'ineq', 'fun': constraint_agua},
    ]

    # --- Define os Limites (Bounds) para as variáveis (quantidades aplicadas por ha) ---
    bounds = [
        (0, max_agua_ha),      # agua_aplicada_ha
        (0, max_n_ha),         # n_aplicado_ha
        (0, max_p_ha),         # p_aplicado_ha
        (0, max_k_ha)          # k_aplicado_ha
    ]

    # --- Ponto Inicial da Otimização ---
    x0 = [max(0, agua_necessaria_min_ha),
          max(0, n_necessario_min_ha - n_solo),
          max(0, p_necessario_min_ha - p_solo),
          max(0, k_necessario_min_ha - k_solo)]

    # Clip x0 to be within bounds
    x0 = [min(max(x0[0], bounds[0][0]), bounds[0][1]),
          min(max(x0[1], bounds[1][0]), bounds[1][1]),
          min(max(x0[2], bounds[2][0]), bounds[2][1]),
          min(max(x0[3], bounds[3][0]), bounds[3][1])]


    # --- Executa a Otimização ---
    with st.spinner('Executando otimização...'):
        try:
            result = minimize(objective_function, x0, method='SLSQP', bounds=bounds, constraints=constraints)
        except Exception as e:
            st.error(f"Ocorreu um erro durante a otimização: {e}")
            return

    # --- Resultados ---
    st.subheader("Resultados Detalhados:")
    if result.success:
        agua_aplicada_ha_otima, n_aplicado_ha_otimo, p_aplicado_ha_otimo, k_aplicado_ha_otimo = result.x

        st.write("Status da Otimização: **Sucesso**")
        st.write(f"Mensagem: {result.message}")
        st.write(f"Lucro Máximo Estimado: **{-result.fun:.2f}**") # Note: minimizing negative lucro

        st.subheader("Quantidades Ótimas de Aplicação (por hectare):")
        st.write(f"- Água: {agua_aplicada_ha_otima:.2f} unidades/ha")
        st.write(f"- Nitrogênio: {n_aplicado_ha_otimo:.2f} kg/ha")
        st.write(f"- Fósforo: {p_aplicado_ha_otimo:.2f} kg/ha")
        st.write(f"- Potássio: {k_aplicado_ha_otimo:.2f} kg/ha")

        # Recalcular métricas com os resultados ótimos para exibição
        n_total_otimo = n_solo + n_aplicado_ha_otimo
        p_total_otimo = p_solo + p_aplicado_ha_otimo
        k_total_otimo = k_solo + k_aplicado_ha_otimo
        agua_total_otimo = agua_aplicada_ha_otima

        producao_ha_estimada_otima = producao_por_ha_modelo(n_total_otimo, p_total_otimo, k_total_otimo, agua_total_otimo, necessidades_cultura)
        producao_total_area_otima = producao_ha_estimada_otima * area_ha

        custo_total_area_otimo = calcular_custo_total_ha(agua_aplicada_ha_otima, n_aplicado_ha_otimo,
                                                          p_aplicado_ha_otimo, k_aplicado_ha_otimo) * area_ha
        lucro_otimo = (producao_total_area_otima * preco_venda_un) - custo_total_area_otimo

        st.subheader("Níveis e Estimativas com Aplicação Ótima:")
        st.write(f"- Nitrogênio Total (Solo + Aplicado) por ha: {n_total_otimo:.2f} kg/ha (Mínimo Necessário: {n_necessario_min_ha:.2f})")
        st.write(f"- Fósforo Total (Solo + Aplicado) por ha: {p_total_otimo:.2f} kg/ha (Mínimo Necessário: {p_necessario_min_ha:.2f})")
        st.write(f"- Potássio Total (Solo + Aplicado) por ha: {k_total_otimo:.2f} kg/ha (Mínimo Necessário: {k_necessario_min_ha:.2f})")
        st.write(f"- Água Aplicada por ha: {agua_aplicada_ha_otima:.2f} unidades/ha (Mínimo Necessário: {agua_necessaria_min_ha:.2f})")


        st.write(f"\nProdução Estimada para a Área Total ({area_ha} ha): {producao_total_area_otima:.2f} unidades")
        st.write(f"Custo Total dos Insumos Aplicados para a Área: {custo_total_area_otimo:.2f}")
        st.write(f"Lucro Estimado para a Área: **{lucro_otimo:.2f}**")

        # Add download button
        optimization_summary = f"""
Otimização de Recursos - Resumo
Status: Sucesso
Lucro Máximo Estimado: {lucro_otimo:.2f}

Quantidades Ótimas de Aplicação (por hectare):
- Água: {agua_aplicada_ha_otima:.2f} unidades/ha
- Nitrogênio: {n_aplicado_ha_otimo:.2f} kg/ha
- Fósforo: {p_aplicado_ha_otimo:.2f} kg/ha
- Potássio: {k_aplicado_ha_otimo:.2f} kg/ha

Níveis e Estimativas com Aplicação Ótima:
- Nitrogênio Total (Solo + Aplicado) por ha: {n_total_otimo:.2f} kg/ha (Mínimo Necessário: {n_necessario_min_ha:.2f})
- Fósforo Total (Solo + Aplicado) por ha: {p_total_otimo:.2f} kg/ha (Mínimo Necessário: {p_necessario_min_ha:.2f})
- Potássio Total (Solo + Aplicado) por ha: {k_total_otimo:.2f} kg/ha (Mínimo Necessário: {k_necessario_min_ha:.2f})
- Água Aplicada por ha: {agua_aplicada_ha_otima:.2f} unidades/ha (Mínimo Necessário: {agua_necessaria_min_ha:.2f})

Estimativas para a Área Total ({area_ha} ha):
- Produção Estimada: {producao_total_area_otima:.2f} unidades
- Custo Total dos Insumos Aplicados para a Área: {custo_total_area_otimo:.2f}
- Lucro Estimado para a Área: {lucro_otimo:.2f}

Parâmetros Utilizados:
- Área: {area_ha} ha
- Nível de N no Solo: {n_solo} kg/ha
- Nível de P no Solo: {p_solo} kg/ha
- Nível de K no Solo: {k_solo} kg/ha
- Necessidade Mínima de Água: {agua_necessaria_min_ha} un/ha
- Necessidade Mínima de N: {n_necessario_min_ha} kg/ha
- Necessidade Mínima de P: {p_necessario_min_ha} kg/ha
- Necessidade Mínima de K: {k_necessario_min_ha} kg/ha
- Custo Água: {custo_agua_un} /unidade
- Custo N: {custo_fertilizante_n_un} /kg
- Custo P: {custo_fertilizante_p_un} /kg
- Custo K: {custo_fertilizante_k_un} /kg
- Limite Máx Água: {max_agua_ha} un/ha
- Limite Máx N: {max_n_ha} kg/ha
- Limite Máx P: {max_p_ha} kg/ha
- Limite Máx K: {max_k_ha} kg/ha
- Preço Venda: {preco_venda_un} /unidade produção
"""
        st.markdown(download_link(optimization_summary, 'otimizacao_agricola_resumo.txt', '📥 Baixar Resumo da Otimização (.txt)'), unsafe_allow_html=True)


    else:
        st.warning("\nResultado da Otimização: **Falhou**")
        st.write(f"Status: {result.message}")
        st.write("Não foi possível encontrar uma solução que satisfaça as restrições com os parâmetros fornecidos.")
        st.info("Verifique se as necessidades mínimas podem ser atendidas dentro dos limites máximos de aplicação, considerando os níveis atuais do solo e os custos.")


# 3. Identificação de Pragas e Doenças (Simulação Estruturada) - Adaptada para Streamlit
def identificacao_pragas_doencas_simulacao_streamlit():
    """
    Simula a identificação de pragas ou doenças.
    Adaptada para Streamlit (usa st.write). Não usa caminhos de arquivo reais nesta versão do app.
    """
    st.subheader("Simulação de Identificação de Pragas e Doenças")

    st.markdown("""
    Esta seção simula o que um sistema de identificação de pragas/doenças baseado em imagem poderia fazer.
    **NENHUMA IMAGEM REAL É PROCESSADA.** O resultado exibido é aleatório para fins de demonstração conceitual.
    Um sistema real exigiria modelos de visão computacional e upload/análise de imagens de campo.
    """)

    # --- Simulação de Predição ---
    pragas_doencas_simuladas = [
        'Ferrugem Asiática (Simulado)',
        'Mancha Alvo (Simulado)',
        'Oídio (Simulado)',
        'Lagarta do Cartucho (Simulado)',
        'Doença Fúngica Não Identificada (Simulado)',
        'Ataque de Inseto (Simulado)',
        'Estresse Hídrico (Simulado)',
        'Deficiência Nutricional (Simulado)',
        'Saudável (Simulado)'
        ]
    resultado_simulado = np.random.choice(pragas_doencas_simuladas)

    st.info(f"Analisando imagem (simulado)... Resultado: **{resultado_simulado}**")

    if 'Simulado' in resultado_simulado and 'Saudável' not in resultado_simulado:
        st.warning("Atenção: Possível problema detectado!")
        st.write("Recomendação (Simulada): Avaliar as condições da lavoura para confirmar a presença do problema.")
        if 'Ferrugem' in resultado_simulado or 'Mancha' in resultado_simulado or 'Oídio' in resultado_simulado:
             st.write("Sugestão: Considerar aplicação de fungicida, se confirmado.")
        elif 'Lagarta' in resultado_simulado or 'Inseto' in resultado_simulado:
             st.write("Sugestão: Considerar aplicação de inseticida, se confirmado.")
        elif 'Hídrico' in resultado_simulado:
             st.write("Sugestão: Verificar regime de irrigação.")
        elif 'Nutricional' in resultado_simulado:
             st.write("Sugestão: Considerar análise de solo/folha e adubação complementar.")
    else:
        st.success("A simulação indica que a lavoura está Saudável (Simulado).")


# 4. Análise de Mercado e Previsão de Preços (Prophet) - Adaptada para Streamlit
def analise_mercado_previsao_precos_streamlit(dados, produto, data_coluna, preco_coluna, periodos_futuro_dias=90):
     """
     Analisa dados de mercado e prevê os preços.
     Adaptada para Streamlit (usa st.write e st.pyplot).
     """
     st.subheader(f"Previsão de Preços de Mercado para: {produto} (Prophet)")
     colunas_necessarias = [data_coluna, preco_coluna, 'Cultura'] # 'Cultura' needed for filtering

     # Validate columns exist
     for coluna in colunas_necessarias:
         if coluna not in dados.columns:
             st.error(f"Erro: A coluna '{coluna}' é necessária para previsão de preços e não foi encontrada no DataFrame.")
             return None # Retorna None em caso de erro

     dados_produto = dados[dados['Cultura'] == produto].copy()

     if dados_produto.empty:
         st.warning(f"Não há dados para o produto '{produto}' para previsão de preços.")
         return None

     # Prepara os dados para o Prophet
     df_prophet = dados_produto[[data_coluna, preco_coluna]].copy()
     df_prophet.columns = ['ds', 'y'] # Rename columns for Prophet

     # Garante que a coluna 'ds' é datetime e remove NaT
     try:
         df_prophet['ds'] = pd.to_datetime(df_prophet['ds'], errors='coerce')
         df_prophet.dropna(subset=['ds'], inplace=True) # Remove rows where date conversion failed
     except Exception as e:
         st.error(f"Erro ao converter a coluna '{data_coluna}' para datetime: {e}")
         st.info("Verifique o formato da data na sua planilha. O Prophet espera formatos reconhecíveis (ex: YYYY-MM-DD). Linhas com datas inválidas foram removidas.")
         return None

     # Agrega por data para ter um único ponto de preço por dia (média)
     df_prophet = df_prophet.groupby('ds')['y'].mean().reset_index()
     # Remove NaNs no preço após agregação (se houver)
     df_prophet.dropna(subset=['y'], inplace=True)


     # Prophet precisa de pelo menos 2 pontos de dados distintos.
     if len(df_prophet) < 2:
          st.warning(f"Após agregação por data, dados insuficientes para o produto '{produto}' para o modelo Prophet ({len(df_prophet)} pontos únicos válidos). São necessários pelo menos 2 pontos de data distintos com preços válidos.")
          return None
     if len(df_prophet) < 10:
         st.info(f"Dados limitados ({len(df_prophet)} pontos únicos válidos) para o modelo Prophet. A previsão pode não capturar sazonalidades complexas.")

     # Sort data by date
     df_prophet = df_prophet.sort_values('ds')

     # Cria e ajusta o modelo Prophet
     with st.spinner('Treinando modelo Prophet...'):
         modelo_prophet = Prophet(
             seasonality_mode='multiplicative',
             weekly_seasonality=True,
             daily_seasonality=False
         )
         # Optional: Add country holidays if relevant and data span years
         # try:
         #     modelo_prophet.add_country_holidays(country_name='BR') # Example for Brazil
         # except Exception as e:
         #     st.info(f"Não foi possível adicionar feriados do país (BR): {e}. Continue sem feriados.")


         try:
            modelo_prophet.fit(df_prophet)
         except Exception as e:
            st.error(f"Erro ao treinar o modelo Prophet: {e}")
            st.info("Verifique se há variação suficiente nos dados de preço ao longo do tempo.")
            return None

     st.success('Modelo Prophet treinado!')

     # Cria um DataFrame para previsões futuras
     future = modelo_prophet.make_future_dataframe(periods=periodos_futuro_dias)
     forecast = modelo_prophet.predict(future)

     # Imprime os resultados da previsão (primeiros e últimos dias da previsão)
     st.subheader(f"Previsão de preços de {produto} para os próximos {periodos_futuro_dias} dias:")
     # Filtrar apenas as datas futuras
     last_historical_date = df_prophet['ds'].max()
     forecast_future = forecast[forecast['ds'] > last_historical_date].reset_index(drop=True)

     if not forecast_future.empty:
        st.write("Primeiros 10 dias previstos:")
        st.dataframe(forecast_future[['ds', 'yhat', 'yhat_lower', 'yhat_upper']].head(10))
        st.write("Últimos 10 dias previstos:")
        st.dataframe(forecast_future[['ds', 'yhat', 'yhat_lower', 'yhat_upper']].tail(10))

        # Add download button for future forecast data
        csv_forecast = forecast_future[['ds', 'yhat', 'yhat_lower', 'yhat_upper']].to_csv(index=False)
        st.markdown(download_link(csv_forecast, f'{produto}_preco_previsto_prophet.csv', '📥 Baixar Previsão Futura (.csv)'), unsafe_allow_html=True)

     else:
        st.info("Não há datas futuras no dataframe de previsão. Verifique o período solicitado ou os dados de entrada.")


     # Plota a previsão
     st.subheader("Gráfico de Previsão:")
     fig1 = modelo_prophet.plot(forecast)
     plt.title(f'Previsão de Preços de {produto} com Prophet')
     plt.xlabel('Data')
     plt.ylabel(f'{preco_coluna}')
     st.pyplot(fig1)
     plt.close(fig1)

     # Plota os componentes da previsão
     st.subheader("Componentes da Previsão:")
     fig2 = modelo_prophet.plot_components(forecast)
     st.pyplot(fig2)
     plt.close(fig2)

     return forecast # Retorna o DataFrame de previsão


# 5. Visualização de Dados e Painéis - Adaptada para Streamlit
def visualizacao_dados_painel_avancado_streamlit(dados, titulo_painel):
    """
    Cria visualizações de dados de exemplo para um painel interativo simulado.
    Adaptada para Streamlit (usa st.pyplot).
    """
    st.subheader(f"Visualizações Gerais dos Dados: {titulo_painel}")

    if dados.empty:
        st.warning("O DataFrame está vazio após o pré-processamento. Não há dados para visualizar.")
        return

    # Exemplo: Distribuição de Produção por Cultura (Boxplot)
    if 'Cultura' in dados.columns and 'Producao' in dados.columns:
        st.write("#### Distribuição de Produção por Cultura")
        try:
            fig, ax = plt.subplots(figsize=(10, 6))
            sns.boxplot(x='Cultura', y='Producao', data=dados, ax=ax)
            ax.set_title('Distribuição de Produção por Cultura')
            ax.set_xlabel('Cultura')
            ax.set_ylabel('Produção')
            plt.xticks(rotation=45, ha='right') # Rotate labels if many cultures
            plt.tight_layout() # Adjust layout
            st.pyplot(fig)
            plt.close(fig)
        except Exception as e:
            st.error(f"Erro ao gerar boxplot de Produção por Cultura: {e}")
            st.info("Verifique se as colunas 'Cultura' e 'Producao' existem e contêm dados válidos.")

    else:
        st.info("Colunas 'Cultura' ou 'Producao' não encontradas para o boxplot de produção.")

    # Exemplo: Relação entre Precipitacao e Producao (Scatter Plot com Hue por Cultura)
    if 'Precipitacao_Total' in dados.columns and 'Producao' in dados.columns and 'Cultura' in dados.columns:
        st.write("#### Relação entre Precipitação e Produção por Cultura")
        try:
            fig, ax = plt.subplots(figsize=(10, 6))
            sns.scatterplot(x='Precipitacao_Total', y='Producao', hue='Cultura', data=dados, alpha=0.6, ax=ax)
            ax.set_title('Relação entre Precipitação e Produção por Cultura')
            ax.set_xlabel('Precipitação Total (mm)')
            ax.set_ylabel('Produção')
            plt.tight_layout()
            st.pyplot(fig)
            plt.close(fig)
        except Exception as e:
            st.error(f"Erro ao gerar scatter plot Precipitação vs Produção: {e}")
            st.info("Verifique se as colunas 'Precipitacao_Total', 'Producao' e 'Cultura' existem e contêm dados numéricos/válidos.")
    else:
         st.info("Colunas 'Precipitacao_Total', 'Producao' ou 'Cultura' não encontradas para o scatter plot.")


    # Exemplo: Média de Níveis de Solo por Tipo de Solo (Bar Plot)
    colunas_solo = ['N_Solo', 'P_Solo', 'K_Solo']
    if 'Tipo_Solo' in dados.columns and all(col in dados.columns for col in colunas_solo):
        st.write("#### Média de Níveis de Nutrientes no Solo por Tipo de Solo")
        try:
            dados_solo_mean = dados.groupby('Tipo_Solo')[colunas_solo].mean().reset_index()
            dados_solo_melted = dados_solo_mean.melt('Tipo_Solo', var_name='Nutriente', value_name='Média_Nível')
            fig, ax = plt.subplots(figsize=(10, 6))
            sns.barplot(x='Tipo_Solo', y='Média_Nível', hue='Nutriente', data=dados_solo_melted, ax=ax)
            ax.set_title('Média de Níveis de Nutrientes no Solo por Tipo de Solo')
            ax.set_xlabel('Tipo de Solo')
            ax.set_ylabel('Média de Nível (kg/ha)')
            plt.tight_layout()
            st.pyplot(fig)
            plt.close(fig)
        except Exception as e:
            st.error(f"Erro ao gerar bar plot Nutrientes por Solo: {e}")
            st.info("Verifique se as colunas 'Tipo_Solo', 'N_Solo', 'P_Solo' e 'K_Solo' existem e contêm dados válidos.")

    else:
         st.info("Colunas 'Tipo_Solo', 'N_Solo', 'P_Solo' ou 'K_Solo' não encontradas para o bar plot de nutrientes.")

    # Adicionar mais visualizações conforme necessário...


# --- Layout Principal do Aplicativo Streamlit ---

st.set_page_config(layout="wide", page_title="Plataforma de Análise Agrícola")

st.title("🌱 Plataforma Interativa de Análise Agrícola")

st.write("""
Esta plataforma oferece ferramentas para análise de dados de safra, previsão de produção e preços,
além de simulação de otimização de recursos e identificação de problemas.
""")

# --- Seção de Como Usar / Requisitos de Dados ---
with st.expander("ℹ️ Como Usar e Requisitos de Dados"):
    st.markdown("""
    1.  **Faça Upload:** Comece fazendo upload do seu arquivo CSV com os dados agrícolas na seção abaixo.
    2.  **Trate Dados Faltantes (Opcional):** Se o seu arquivo tiver valores faltantes, use a seção de "Tratamento de Dados Faltantes" na barra lateral para decidir como lidar com eles.
    3.  **Selecione a Análise:** Use a barra lateral para escolher a análise que deseja realizar (Visualizações, Previsão de Safra, Otimização, Simulação de Pragas/Doenças, Previsão de Preços).
    4.  **Configure os Parâmetros:** Em cada seção de análise, configure os parâmetros necessários (selecionar cultura, inserir valores de otimização, etc.).
    5.  **Execute a Análise:** Clique no botão para rodar a análise e visualizar os resultados.

    **Estrutura de Dados Esperada (para todas as análises funcionarem plenamente):**

    Seu arquivo CSV deve conter colunas relevantes para as análises que você deseja rodar. Nomes de colunas comuns incluem:
    -   `Cultura` (Nome da cultura/produto)
    -   `Area_Colhida` (Área colhida em hectares)
    -   `Precipitacao_Total` (Precipitação total durante o ciclo)
    -   `Temp_Media_Ciclo` (Temperatura média durante o ciclo)
    -   `Horas_Sol_Ciclo` (Horas de sol durante o ciclo)
    -   `Tipo_Solo` (Ex: Argiloso, Arenoso, etc.)
    -   `Manejo` (Ex: Convencional, Orgânico, etc.)
    -   `N_Solo`, `P_Solo`, `K_Solo` (Níveis de nutrientes no solo)
    -   `Producao` (Produção obtida)
    -   `Data_Ciclo` (Data de referência para o ciclo, para previsão de preços)
    -   `Preco_Venda` (Preço de venda da produção, para previsão de preços)

    *O aplicativo tenta adaptar-se a nomes de colunas ligeiramente diferentes, mas seguir essa convenção ou renomear suas colunas ajudará a garantir que todas as funcionalidades estejam disponíveis.*
    """)


# --- Seção de Upload de Dados ---
st.header("1. Upload dos Dados Agrícolas")

uploaded_file = st.file_uploader("Escolha um arquivo CSV (.csv) com seus dados", type="csv", key='csv_upload')

df_original = None # Inicializa df_original como None
df = None # df will be the processed dataframe

if uploaded_file is not None:
    try:
        # Use cache_data para evitar recarregar em cada interação se o arquivo for o mesmo
        @st.cache_data
        def load_and_clean_data(file):
            data = pd.read_csv(file)
            # Clean column names: remove leading/trailing spaces, special characters, replace spaces with underscore
            data.columns = data.columns.str.strip().str.replace(' ', '_').str.replace('[^A-Za-z0-9_]+', '', regex=True)
            # Ensure 'Cultura' is string type if it exists
            if 'Cultura' in data.columns:
                 data['Cultura'] = data['Cultura'].astype(str)
            return data

        df_original = load_and_clean_data(uploaded_file)
        df = df_original.copy() # Work on a copy to allow manipulation (like dropna)

        st.success("Arquivo carregado com sucesso!")
        st.write("Primeiras 5 linhas dos dados:")
        st.dataframe(df.head())

        st.write(f"O DataFrame contém {df.shape[0]} linhas e {df.shape[1]} colunas.")

        # Exibe os nomes das colunas carregadas para referência do usuário
        st.write("Colunas carregadas (nomes limpos):")
        st.code(", ".join(df.columns.tolist()))

        # Optional: Show missing values
        st.write("Valores faltantes por coluna:")
        missing_values = df.isnull().sum()
        missing_values = missing_values[missing_values > 0]
        if not missing_values.empty:
            st.dataframe(missing_values.rename("Quantidade Faltante"))
        else:
            st.info("Nenhum valor faltante encontrado nos dados.")


    except pd.errors.EmptyDataError:
         st.error("O arquivo CSV está vazio.")
         df_original = None
         df = None
    except Exception as e:
        st.error(f"Ocorreu um erro ao carregar ou ler o arquivo: {e}")
        df_original = None
        df = None

# --- Seções de Análise (Visível apenas se dados forem carregados) ---

if df is not None and not df.empty:

    # Adiciona a barra lateral para seleção de análises e tratamento de dados
    st.sidebar.title("Navegação e Análises")
    analise_selecionada = st.sidebar.radio(
        "Escolha a Análise:",
        ['Visualizações Gerais', 'Tratamento de Dados Faltantes', 'Previsão de Safra', 'Otimização de Recursos', 'Simulação Pragas/Doenças', 'Previsão de Preços'],
        key='main_analysis_radio'
    )

    st.header(f"Seção: {analise_selecionada}")

    # --- 1. Visualizações Gerais ---
    if analise_selecionada == 'Visualizações Gerais':
        visualizacao_dados_painel_avancado_streamlit(df, 'Dados Carregados')

    # --- 2. Tratamento de Dados Faltantes ---
    # Place this section *before* analyses that might require clean data
    elif analise_selecionada == 'Tratamento de Dados Faltantes':
         st.subheader("Tratamento de Dados Faltantes")
         st.markdown("""
         Seus dados contêm valores faltantes (NaN). Escolha um método para tratá-los antes de executar as análises.
         **Atenção:** O tratamento será aplicado ao DataFrame *dentro* deste aplicativo e afetará todas as análises subsequentes.
         """)

         missing_values_current = df.isnull().sum()
         missing_values_current = missing_values_current[missing_values_current > 0]

         if missing_values_current.empty:
             st.success("Não há valores faltantes no DataFrame atual.")
         else:
             st.write("Colunas com valores faltantes:")
             st.dataframe(missing_values_current.rename("Quantidade Faltante"))

             method = st.radio(
                 "Escolha o método para tratar valores faltantes:",
                 ('Nenhum (Usar dados como estão)', 'Remover linhas com qualquer valor faltante', 'Remover colunas com valor faltante', 'Imputar com a Média (Colunas Numéricas)', 'Imputar com a Mediana (Colunas Numéricas)', 'Imputar com a Moda (Colunas Categóricas/Não Numéricas)')
                 , key='missing_value_method'
             )

             df_processed = df.copy() # Create a copy to apply treatment

             if method == 'Remover linhas com qualquer valor faltante':
                 rows_before = len(df_processed)
                 df_processed.dropna(inplace=True)
                 rows_after = len(df_processed)
                 st.success(f"Removidas {rows_before - rows_after} linhas com valores faltantes.")
             elif method == 'Remover colunas com valor faltante':
                 cols_before = len(df_processed.columns)
                 df_processed.dropna(axis=1, inplace=True)
                 cols_after = len(df_processed.columns)
                 st.success(f"Removidas {cols_before - cols_after} colunas com valores faltantes.")
             elif 'Imputar com a' in method:
                 if 'Média' in method or 'Mediana' in method:
                     # Impute numerical columns
                     numeric_cols_with_missing = df_processed.select_dtypes(include=np.number).columns[df_processed.select_dtypes(include=np.number).isnull().any()]
                     if not numeric_cols_with_missing.empty:
                         strategy = 'mean' if 'Média' in method else 'median'
                         imputation_values = df_processed[numeric_cols_with_missing].agg(strategy)
                         df_processed[numeric_cols_with_missing] = df_processed[numeric_cols_with_missing].fillna(imputation_values)
                         st.success(f"Valores faltantes imputados com a {strategy} nas colunas numéricas: {', '.join(numeric_cols_with_missing)}")
                     else:
                         st.info("Não há colunas numéricas com valores faltantes para imputar com média/mediana.")
                 elif 'Moda' in method:
                     # Impute non-numerical/categorical columns
                     object_cols_with_missing = df_processed.select_dtypes(exclude=np.number).columns[df_processed.select_dtypes(exclude=np.number).isnull().any()]
                     if not object_cols_with_missing.empty:
                         for col in object_cols_with_missing:
                             mode_val = df_processed[col].mode()
                             if not mode_val.empty:
                                 df_processed[col] = df_processed[col].fillna(mode_val[0])
                                 st.success(f"Valores faltantes imputados com a moda na coluna '{col}'.")
                             else:
                                 st.warning(f"Não foi possível encontrar a moda para imputação na coluna '{col}'.")
                     else:
                         st.info("Não há colunas não numéricas com valores faltantes para imputar com a moda.")

             # Update the global df variable that other analyses will use
             df = df_processed.copy() # Use a copy to avoid potential streamlit state issues

             st.write("Status dos valores faltantes após tratamento:")
             missing_values_after = df.isnull().sum()
             missing_values_after = missing_values_after[missing_values_after > 0]
             if not missing_values_after.empty:
                 st.dataframe(missing_values_after.rename("Quantidade Faltante Após Tratamento"))
             else:
                 st.success("Todos os valores faltantes foram tratados.")

             st.write("Primeiras 5 linhas do DataFrame após tratamento:")
             st.dataframe(df.head())


    # --- 3. Previsão de Safra (Gradient Boosting) ---
    elif analise_selecionada == 'Previsão de Safra':
        st.write("Esta análise prevê a produção de safra com base em fatores ambientais e de manejo usando Machine Learning.")

        # Define default columns - check if they exist
        default_features_ml = ['Area_Colhida', 'Precipitacao_Total', 'Temp_Media_Ciclo', 'Horas_Sol_Ciclo', 'N_Solo', 'P_Solo', 'K_Solo']
        default_categorical_features_ml = ['Tipo_Solo', 'Manejo']
        default_target_ml = 'Producao'
        default_cultura_col = 'Cultura'

        # Check if 'Cultura' column exists for filtering
        if default_cultura_col not in df.columns:
             st.warning(f"Coluna '{default_cultura_col}' não encontrada no DataFrame. A previsão de safra por cultura não pode ser realizada.")
        elif default_target_ml not in df.columns:
             st.warning(f"Coluna target '{default_target_ml}' não encontrada no DataFrame. A previsão de safra não pode ser realizada.")
        else:
            culturas_disponiveis = df[default_cultura_col].unique().tolist()
            cultura_para_prever_safra = st.selectbox(
                "Selecione a Cultura para previsão de safra:",
                ['-- Selecione --'] + culturas_disponiveis,
                 key='safra_cultura_select'
            )

            # Get all available columns for feature selection
            all_cols = df.columns.tolist()
            # Exclude target and culture from selectable features
            possible_features = [col for col in all_cols if col not in [default_target_ml, default_cultura_col]]

            st.subheader("Configuração do Modelo ML")

            # Feature Selection
            selected_features = st.multiselect(
                "Selecione as features numéricas para o modelo:",
                [f for f in possible_features if df[f].dtype in [np.number, 'int64', 'float64']],
                default=[f for f in default_features_ml if f in possible_features and df[f].dtype in [np.number, 'int64', 'float64']], # Pre-select defaults that exist and are numeric
                key='ml_num_features_select'
            )
            selected_categorical_features = st.multiselect(
                "Selecione as features categóricas para o modelo:",
                 [f for f in possible_features if df[f].dtype not in [np.number, 'int64', 'float64']],
                 default=[f for f in default_categorical_features_ml if f in possible_features and df[f].dtype not in [np.number, 'int64', 'float64']], # Pre-select defaults that exist and are non-numeric
                 key='ml_cat_features_select'
            )

            # Model Selection
            model_choice = st.selectbox(
                 "Escolha o Modelo de Machine Learning:",
                 ('Gradient Boosting Regressor', 'Random Forest Regressor', 'Linear Regression'),
                 key='ml_model_select'
            )


            if cultura_para_prever_safra != '-- Selecione --':
                if not selected_features and not selected_categorical_features:
                    st.warning("Por favor, selecione pelo menos uma feature (numérica ou categórica) para treinar o modelo.")
                else:
                    # Final check if selected features exist in the dataframe after potential missing value handling
                    all_selected = selected_features + selected_categorical_features
                    if not all(col in df.columns for col in all_selected):
                        missing_sel = [col for col in all_selected if col not in df.columns]
                        st.error(f"Uma ou mais features selecionadas não existem no DataFrame após o tratamento de dados: {', '.join(missing_sel)}. Por favor, revise sua seleção ou o tratamento de dados.")
                    else:
                        if st.button(f"Executar Previsão de Safra para {cultura_para_prever_safra}", key='run_safra_button'):
                            analise_previsao_safras_avancado(df, cultura_para_prever_safra,
                                                            features=selected_features,
                                                            categorical_features=selected_categorical_features,
                                                            target=default_target_ml,
                                                            model_name=model_choice)
            else:
                 st.info("Selecione uma cultura para executar a análise de safra.")


    # --- 4. Otimização do Uso de Recursos ---
    elif analise_selecionada == 'Otimização de Recursos':
        st.write("Esta seção calcula as quantidades ótimas de água e fertilizantes a serem aplicados para maximizar o lucro, com base nos custos, necessidades da cultura e níveis atuais do solo.")
        st.warning("O modelo de produção utilizado nesta otimização é **conceitual e simplificado**. Ele não substitui modelos agronômicos calibrados com dados reais da sua região e cultura.")

        # Entradas do usuário para otimização
        st.subheader("Parâmetros para Otimização")
        area_otimizacao = st.number_input("Área para otimização (hectares)", min_value=1.0, value=10.0, step=1.0, format="%.2f", key='area_otim')

        st.subheader("Níveis Atuais de Nutrientes no Solo (por hectare)")
        n_solo_otim = st.number_input("Nitrogênio (N) no solo (kg/ha)", min_value=0.0, value=50.0, step=1.0, format="%.2f", key='n_solo_otim')
        p_solo_otim = st.number_input("Fósforo (P) no solo (kg/ha)", min_value=0.0, value=30.0, step=1.0, format="%.2f", key='p_solo_otim')
        k_solo_otim = st.number_input("Potássio (K) no solo (kg/ha)", min_value=0.0, value=80.0, step=1.0, format="%.2f", key='k_solo_otim')

        st.subheader("Necessidades Mínimas da Cultura (por hectare)")
        st.info("Informe os níveis MÍNIMOS de insumos totais (solo + aplicado) necessários por hectare para que a cultura se desenvolva.")
        agua_nec_ha = st.number_input("Necessidade mínima de água (unidades/ha)", min_value=0.0, value=100.0, step=1.0, format="%.2f", key='agua_nec_ha')
        n_nec_ha = st.number_input("Necessidade mínima de N (kg/ha)", min_value=0.0, value=120.0, step=1.0, format="%.2f", key='n_nec_ha')
        p_nec_ha = st.number_input("Necessidade mínima de P (kg/ha)", min_value=0.0, value=60.0, step=1.0, format="%.2f", key='p_nec_ha')
        k_nec_ha = st.number_input("Necessidade mínima de K (kg/ha)", min_value=0.0, value=150.0, step=1.0, format="%.2f", key='k_nec_ha')
        necessidades_cultura_otim = {'agua': agua_nec_ha, 'nitrogenio': n_nec_ha, 'fosforo': p_nec_ha, 'potassio': k_nec_ha}


        st.subheader("Custos por Unidade de Insumo")
        st.info("Informe o custo por unidade (ex: R$/unidade de água, R$/kg de nutriente).")
        custo_agua = st.number_input("Custo da água (por unidade)", min_value=0.0, value=0.5, step=0.01, format="%.2f", key='custo_agua')
        custo_n = st.number_input("Custo do fertilizante N (por kg)", min_value=0.0, value=2.5, step=0.01, format="%.2f", key='custo_n')
        custo_p = st.number_input("Custo do fertilizante P (por kg)", min_value=0.0, value=3.0, step=0.01, format="%.2f", key='custo_p')
        custo_k = st.number_input("Custo do fertilizante K (por kg)", min_value=0.0, value=2.0, step=0.01, format="%.2f", key='custo_k')
        custos_otim = {'agua': custo_agua, 'nitrogenio': custo_n, 'fosforo': custo_p, 'potassio': custo_k}

        st.subheader("Limites Máximos de Aplicação (por hectare)")
        st.info("Defina os limites máximos práticos de aplicação por hectare para cada insumo.")
        max_agua = st.number_input("Máx. água (unidades/ha)", min_value=0.0, value=500.0, step=10.0, format="%.2f", key='max_agua')
        max_n = st.number_input("Máx. N (kg/ha)", min_value=0.0, value=200.0, step=5.0, format="%.2f", key='max_n')
        max_p = st.number_input("Máx. P (kg/ha)", min_value=0.0, value=150.0, step=5.0, format="%.2f", key='max_p')
        max_k = st.number_input("Máx. K (kg/ha)", min_value=0.0, value=250.0, step=5.0, format="%.2f", key='max_k')
        limites_aplicacao_otim = {'agua': max_agua, 'nitrogenio': max_n, 'fosforo': max_p, 'potassio': max_k}

        st.subheader("Preço de Venda da Produção")
        st.info("Informe o preço esperado por unidade da produção (ex: R$/ton).")
        preco_venda_un = st.number_input("Preço de venda por unidade de produção", min_value=0.01, value=1500.0, step=10.0, format="%.2f", key='preco_venda_otim')


        if st.button("Executar Otimização", key='run_otim_button'):
            otimizacao_uso_recursos_avancado_streamlit(n_solo_otim, p_solo_otim, k_solo_otim, area_otimizacao,
                                                        necessidades_cultura_otim, custos_otim, limites_aplicacao_otim, preco_venda_un)


    # --- 5. Simulação Identificação Pragas/Doenças ---
    elif analise_selecionada == 'Simulação Pragas/Doenças':
        st.write("Esta seção demonstra o conceito de identificação de pragas ou doenças via análise de imagem.")
        identificacao_pragas_doencas_simulacao_streamlit()


    # --- 6. Previsão de Preços (Prophet) ---
    elif analise_selecionada == 'Previsão de Preços':
         st.write("Esta análise utiliza o modelo Prophet para prever tendências de preços futuros com base no histórico.")

         # Get available columns for user selection
         available_cols = df.columns.tolist()
         # Try to pre-select common columns
         default_date_col = 'Data_Ciclo' if 'Data_Ciclo' in available_cols else (available_cols[0] if available_cols else None)
         default_price_col = 'Preco_Venda' if 'Preco_Venda' in available_cols else ('Producao' if 'Producao' in available_cols else (available_cols[1] if len(available_cols)>1 else None))
         default_cultura_col = 'Cultura' if 'Cultura' in available_cols else (available_cols[2] if len(available_cols)>2 else None)


         st.subheader("Configuração da Previsão de Preços")
         st.info("Selecione as colunas que contêm a Data, o Preço e a identificação da Cultura/Produto.")

         date_col_price = st.selectbox("Selecione a coluna de Data:", available_cols, index=available_cols.index(default_date_col) if default_date_col in available_cols else 0, key='preco_date_col_select')
         price_col_price = st.selectbox("Selecione a coluna de Preço:", available_cols, index=available_cols.index(default_price_col) if default_price_col in available_cols else (1 if len(available_cols)>1 else 0), key='preco_price_col_select')

         # Check if 'Cultura' column is available for filtering
         if default_cultura_col not in df.columns:
             st.warning(f"Coluna '{default_cultura_col}' não encontrada. A previsão de preços por produto/cultura não é possível. Rode a análise com todos os dados como um único produto.")
             # Option to treat all data as one product
             treat_as_single_product = st.checkbox("Tratar todos os dados como um único produto?", key='single_product_mode')
             if treat_as_single_product:
                  produto_para_prever_preco = "Todos os Produtos" # Use a placeholder
                  periodos_futuro = st.number_input("Quantos dias no futuro prever?", min_value=1, value=90, step=7, key='dias_futuro_preco')

                  # Validate selected columns before running
                  if date_col_price not in df.columns or price_col_price not in df.columns:
                       st.error(f"As colunas selecionadas ('{date_col_price}', '{price_col_price}') não existem no DataFrame. Por favor, revise.")
                  else:
                       if st.button(f"Executar Previsão de Preços para {produto_para_prever_preco}", key='run_preco_button'):
                            # Create a dummy 'Cultura' column if treating as single product
                            df_single_product = df.copy()
                            df_single_product['Cultura'] = produto_para_prever_preco # Assign a constant value
                            analise_mercado_previsao_precos_streamlit(df_single_product, produto_para_prever_preco,
                                                                     data_coluna=date_col_price,
                                                                     preco_coluna=price_col_price,
                                                                     periodos_futuro_dias=periodos_futuro)

             else:
                  st.info("Selecione a opção 'Tratar todos os dados como um único produto' se não tiver uma coluna 'Cultura'.")


         else: # 'Cultura' column exists
             culturas_disponiveis_preco = df['Cultura'].unique().tolist()
             produto_para_prever_preco = st.selectbox(
                 "Selecione o Produto (Cultura) para previsão de preço:",
                 ['-- Selecione --'] + culturas_disponiveis_preco,
                 key='preco_produto_select'
             )
             periodos_futuro = st.number_input("Quantos dias no futuro prever?", min_value=1, value=90, step=7, key='dias_futuro_preco')

             if produto_para_prever_preco != '-- Selecione --':
                 # Validate selected columns before running
                 if date_col_price not in df.columns or price_col_price not in df.columns:
                      st.error(f"As colunas selecionadas ('{date_col_price}', '{price_col_price}') não existem no DataFrame. Por favor, revise.")
                 else:
                      if st.button(f"Executar Previsão de Preços para {produto_para_prever_preco}", key='run_preco_button'):
                         analise_mercado_previsao_precos_streamlit(df, produto_para_prever_preco,
                                                                   data_coluna=date_col_price,
                                                                   preco_coluna=price_col_price,
                                                                   periodos_futuro_dias=periodos_futuro)
             else:
                 st.info("Selecione um produto para executar a previsão de preços.")

else:
    st.info("Aguardando o upload do arquivo CSV para exibir as opções de análise.")
    st.markdown("""
    Por favor, faça o upload do seu arquivo CSV na seção acima para começar.
    """)

# Footer opcional
st.sidebar.markdown("---")
st.sidebar.info("Desenvolvido como exemplo de aplicação agrícola com Python e Streamlit.")