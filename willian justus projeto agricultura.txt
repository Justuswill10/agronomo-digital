import streamlit as st
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.model_selection import train_test_split
from sklearn.ensemble import GradientBoostingRegressor, RandomForestRegressor
from sklearn.linear_model import LinearRegression # Added for model comparison
from sklearn.metrics import mean_squared_error, r2_score
from prophet import Prophet
from scipy.optimize import minimize
import warnings
import os
import base64 # To enable download button

# Suprimir warnings para uma sa√≠da mais limpa no Streamlit
warnings.filterwarnings('ignore')
# Configurar estilo do matplotlib
plt.style.use('seaborn-v0_8-whitegrid')

# --- DEFINI√á√ÉO DAS FUN√á√ïES DO PROJETO AVAN√áADO (Adaptadas para Streamlit) ---

# Helper function para o modelo de produ√ß√£o na otimiza√ß√£o
def producao_por_ha_modelo(n_total, p_total, k_total, agua_total, necessidades_cultura):
    """
    Modelo SIMPLIFICADO de produ√ß√£o por hectare baseado na satura√ß√£o de insumos.
    Este √© um modelo conceitual para fins de otimiza√ß√£o DEMOSTRATIVA.
    Um modelo real exigiria calibra√ß√£o com dados de campo.
    """
    agua_necessaria_min_ha = necessidades_cultura.get('agua', 0)
    n_necessario_min_ha = necessidades_cultura.get('nitrogenio', 0)
    p_necessario_min_ha = necessidades_cultura.get('fosforo', 0)
    k_necessario_min_ha = necessidades_cultura.get('potassio', 0)

    prod_base = 2000 # Produ√ß√£o base por ha (sem insumos √≥timos no modelo)
    # Respostas simuladas com satura√ß√£o (usando tanh)
    # Resposta > 0 apenas se total > minimo necessario
    resp_n = np.tanh(max(0, n_total - n_necessario_min_ha) / 20) * 500
    resp_p = np.tanh(max(0, p_total - p_necessario_min_ha) / 10) * 400
    resp_k = np.tanh(max(0, k_total - k_necessario_min_ha) / 15) * 300
    resp_agua = np.tanh(max(0, agua_total - agua_necessaria_min_ha) / 50) * 600


    # Combina√ß√£o com fator limitante (simplificado)
    # A produ√ß√£o extra √© limitada pelo insumo mais deficiente *acima* do m√≠nimo necess√°rio.
    # A 'sufici√™ncia relativa' acima do m√≠nimo necess√°rio, normalizada.
    # Usamos um pequeno valor epsilon para evitar divis√£o por zero ou log(0) se min_nec for 0
    epsilon = 1e-9

    suff_n_rel = max(0, (n_total - n_necessario_min_ha)) / (max(epsilon, 200 - n_necessario_min_ha)) # Assume max response reached around 200 above min
    suff_p_rel = max(0, (p_total - p_necessario_min_ha)) / (max(epsilon, 100 - p_necessario_min_ha)) # Assume max response reached around 100 above min
    suff_k_rel = max(0, (k_total - k_necessario_min_ha)) / (max(epsilon, 150 - k_necessario_min_ha)) # Assume max response reached around 150 above min
    suff_agua_rel = max(0, (agua_total - agua_necessaria_min_ha)) / (max(epsilon, 400 - agua_necessaria_min_ha)) # Assume max response reached around 400 above min

    # Ensure relative sufficiency is not > 1 if inputs exceed model range
    suff_n_rel = min(1.0, suff_n_rel)
    suff_p_rel = min(1.0, suff_p_rel)
    suff_k_rel = min(1.0, suff_k_rel)
    suff_agua_rel = min(1.0, suff_agua_rel)


    # O fator limitante √© o m√≠nimo da sufici√™ncia relativa, mas apenas se *todos* os insumos estiverem acima do m√≠nimo necess√°rio
    if n_total >= n_necessario_min_ha and p_total >= p_necessario_min_ha and k_total >= k_necessario_min_ha and agua_total >= agua_necessaria_min_ha:
         limiting_factor = min(suff_n_rel, suff_p_rel, suff_k_rel, suff_agua_rel)
    else:
         # Se algum insumo total n√£o atinge o m√≠nimo necess√°rio, a produ√ß√£o base √© impactada
         # Um fator de redu√ß√£o baseado em qu√£o longe do m√≠nimo o mais deficiente est√°
         min_needed_factors = [n_necessario_min_ha, p_necessario_min_ha, k_necessario_min_ha, agua_necessaria_min_ha]
         total_levels = [n_total, p_total, k_total, agua_total]
         # Calculate the ratio of total level to minimum needed for those below the minimum
         ratios_below_min = [total_levels[i] / min_needed_factors[i] for i in range(4) if total_levels[i] < min_needed_factors[i] and min_needed_factors[i] > 0]

         if ratios_below_min:
              reduction_factor = min(ratios_below_min) # The most deficient factor determines the reduction
              return prod_base * reduction_factor # Production is reduced proportionally from base if below minimums
         else:
              limiting_factor = 0 # Should not happen if the first condition is false, but for safety


    # O ganho √© aplicado apenas se todos os m√≠nimos forem atingidos e h√° "sufici√™ncia extra"
    # A produ√ß√£o total √© base + ganho modulado pelo fator limitante
    # Total potential gain if all were optimal (using the tanh max responses)
    potential_gain = 500 + 400 + 300 + 600

    # O ganho real √© o ganho potencial * o fator limitante (que agora reflete a sufici√™ncia acima do m√≠nimo)
    actual_gain = potential_gain * limiting_factor

    producao_ha_estimada = prod_base + actual_gain


    return max(prod_base * 0.1, producao_ha_estimada) # Produ√ß√£o n√£o cai abaixo de um m√≠nimo severo (ex: 10% da base)


# Helper function to create download link
def download_link(data, filename, text):
    b64 = base64.b64encode(data.encode()).decode()
    href = f'<a href="data:file/csv;base64,{b64}" download="{filename}">{text}</a>'
    return href


# 1. An√°lise e Previs√£o de Safras (com Modelos ML)
def analise_previsao_safras_avancado(dados, cultura, features, categorical_features, target, model_name):
    """
    Realiza an√°lise e previs√£o de safra para uma cultura usando um modelo ML selecionado.
    Adaptada para Streamlit (usa st.write e st.pyplot).
    """
    st.subheader(f"Resultados da An√°lise de Safra para a cultura: {cultura}")

    dados_cultura = dados[dados['Cultura'] == cultura].copy()

    if dados_cultura.empty:
        st.warning(f"N√£o h√° dados para a cultura '{cultura}'.")
        return
    if len(dados_cultura) < 10:
         st.info(f"Dados limitados para a cultura '{cultura}' ({len(dados_cultura)} amostras). A precis√£o do modelo pode ser limitada.")


    # Seleciona features que realmente existem no DataFrame
    features_num = [f for f in features if f in dados_cultura.columns]
    features_cat = [f for f in categorical_features if f in dados_cultura.columns]
    features_disponiveis = features_num + features_cat

    if target not in dados_cultura.columns:
         st.error(f"A coluna target '{target}' n√£o foi encontrada no DataFrame. N√£o √© poss√≠vel treinar o modelo.")
         return
    if not features_disponiveis:
         st.warning("Nenhuma das features selecionadas foi encontrada no DataFrame. O modelo n√£o pode ser treinado.")
         return

    X = dados_cultura[features_disponiveis].copy() # Usar copy para evitar SettingWithCopyWarning
    y = dados_cultura[target].copy()

    # Trata vari√°veis categ√≥ricas (One-Hot Encoding)
    if features_cat:
        cat_cols_exist = [col for col in features_cat if col in X.columns]
        if cat_cols_exist:
            X = pd.get_dummies(X, columns=cat_cols_exist, drop_first=True)
        else:
            st.info("Nenhuma das colunas categ√≥ricas selecionadas foi encontrada nos dados desta cultura.")

    # Remove colunas de X que n√£o s√£o num√©ricas ap√≥s o one-hot encoding (seguran√ßa)
    X = X.select_dtypes(include=np.number)
    if X.empty:
        st.error("DataFrame de features (X) est√° vazio ou n√£o cont√©m colunas num√©ricas ap√≥s o pr√©-processamento.")
        return


    # Divide os dados
    total_samples = len(X)
    if total_samples < 2:
        st.warning(f"Dados insuficientes para modelagem ({total_samples} amostras).")
        return

    is_split = True
    # Ajusta o test_size para garantir que haja dados suficientes para treino e teste (pelo menos 1 em cada)
    if total_samples < 10:
        st.info(f"Poucos dados para um split robusto ({total_samples} amostras). Treinando e avaliando no conjunto completo.")
        X_train, X_test, y_train, y_test = X, X, y, y # Train and test on the same set
        is_split = False
    else:
        try:
             # Ensure test set has at least 1 sample, test_size between 0.1 and 0.5
             test_size = min(0.5, max(0.1, 1 / total_samples)) # Guarantee at least 1 sample in test if possible
             if total_samples * test_size < 1: # Fallback if test_size calculation is problematic for tiny sets
                  test_size = 0.5 if total_samples >=2 else 0
             if test_size > 0:
                X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=test_size, random_state=42)
                # Re-check if split resulted in empty sets (can happen with weird splits/data)
                if X_train.empty or X_test.empty or y_train.empty or y_test.empty:
                    st.warning("Split resultou em conjuntos vazios. Treinando e avaliando no conjunto completo.")
                    X_train, X_test, y_train, y_test = X, X, y, y
                    is_split = False
             else:
                 st.warning("N√£o foi poss√≠vel realizar o split dos dados com test_size > 0. Treinando e avaliando no conjunto completo.")
                 X_train, X_test, y_train, y_test = X, X, y, y
                 is_split = False


        except ValueError as e:
             st.warning(f"N√£o foi poss√≠vel realizar o split dos dados: {e}. Treinando e avaliando no conjunto completo.")
             X_train, X_test, y_train, y_test = X, X, y, y
             is_split = False

    # Cria e treina o modelo selecionado
    st.write(f"Modelo selecionado: **{model_name}**")
    with st.spinner(f'Treinando modelo {model_name} para {cultura}...'):
        if model_name == 'Gradient Boosting Regressor':
            modelo = GradientBoostingRegressor(n_estimators=100, learning_rate=0.1, max_depth=3, random_state=42)
        elif model_name == 'Random Forest Regressor':
            modelo = RandomForestRegressor(n_estimators=100, random_state=42)
        elif model_name == 'Linear Regression':
             modelo = LinearRegression() # Linear regression is simpler
        else:
            st.error("Modelo ML n√£o reconhecido.")
            return

        try:
            modelo.fit(X_train, y_train)
        except Exception as e:
             st.error(f"Erro durante o treinamento do modelo: {e}")
             st.info("Verifique se as features selecionadas s√£o num√©ricas e n√£o cont√™m valores infinitos.")
             return

    st.success(f'Modelo {model_name} treinado!')

    # Faz previs√µes
    try:
        y_pred_train = modelo.predict(X_train)
        y_pred_test = modelo.predict(X_test)
    except Exception as e:
         st.error(f"Erro durante a previs√£o com o modelo: {e}")
         return


    # Avalia o desempenho do modelo
    st.subheader("M√©tricas de Desempenho do Modelo:")
    mse_train = mean_squared_error(y_train, y_pred_train)
    r2_train = r2_score(y_train, y_pred_train)

    st.write(f"**MSE (Treinamento):** {mse_train:.2f}")
    st.write(f"**R¬≤ (Treinamento):** {r2_train:.2f}")

    if is_split:
        mse_test = mean_squared_error(y_test, y_pred_test)
        r2_test = r2_score(y_test, y_pred_test)
        st.write(f"**MSE (Teste):** {mse_test:.2f}")
        st.write(f"**R¬≤ (Teste):** {r2_test:.2f}")
    else:
         st.info("M√©tricas de teste calculadas no mesmo conjunto de treino devido ao tamanho dos dados. R¬≤ no treino pode ser superestimado.")


    # Exemplo de Feature Importances (para modelos baseados em √°rvore)
    if hasattr(modelo, 'feature_importances_'):
        st.subheader("Import√¢ncia das Features (Top 5):")
        importances = pd.Series(modelo.feature_importances_, index=X_train.columns)
        st.dataframe(importances.sort_values(ascending=False).head())
    elif hasattr(modelo, 'coef_'):
         st.subheader("Coeficientes do Modelo (Linear Regression):")
         coefficients = pd.Series(modelo.coef_, index=X_train.columns)
         st.dataframe(coefficients.sort_values(ascending=False).head())


    # Visualiza os resultados (Observado vs. Previsto)
    st.subheader("Visualiza√ß√£o dos Resultados:")
    fig1, axes = plt.subplots(1, 2 if is_split else 1, figsize=(12, 6))

    # Ensure axes is an array even if there's only one subplot
    if not is_split:
         axes = [axes]

    # Plot Treinamento
    axes[0].scatter(y_train, y_pred_train, alpha=0.6, label='Treinamento')
    # Add identity line
    lims = [min(y_train.min(), y_pred_train.min()), max(y_train.max(), y_pred_train.max())]
    axes[0].plot(lims, lims, '--k', alpha=0.7, label='Ideal')
    axes[0].set_title('Produ√ß√£o Observada vs. Prevista (Treinamento)')
    axes[0].set_xlabel('Produ√ß√£o Observada')
    axes[0].set_ylabel('Produ√ß√£o Prevista')
    axes[0].legend()


    # Plot Teste (if split)
    if is_split:
        axes[1].scatter(y_test, y_pred_test, alpha=0.6, color='orange', label='Teste')
        # Add identity line based on test data range
        lims_test = [min(y_test.min(), y_pred_test.min()), max(y_test.max(), y_pred_test.max())]
        axes[1].plot(lims_test, lims_test, '--k', alpha=0.7, label='Ideal')
        axes[1].set_title('Produ√ß√£o Observada vs. Prevista (Teste)')
        axes[1].set_xlabel('Produ√ß√£o Observada')
        axes[1].set_ylabel('Produ√ß√£o Prevista')
        axes[1].legend()


    plt.tight_layout()
    st.pyplot(fig1)
    plt.close(fig1)


    # Visualiza Res√≠duos
    fig2, axes = plt.subplots(1, 2 if is_split else 1, figsize=(12, 6))
    if not is_split:
         axes = [axes]

    residuos_train = y_train - y_pred_train
    axes[0].scatter(y_pred_train, residuos_train, alpha=0.6, label='Treinamento')
    axes[0].axhline(y=0, color='r', linestyle='--')
    axes[0].set_title('Res√≠duos vs. Valores Previstos (Treinamento)')
    axes[0].set_xlabel('Valores Previstos')
    axes[0].set_ylabel('Res√≠duos')
    axes[0].legend()

    if is_split:
        residuos_test = y_test - y_pred_test
        axes[1].scatter(y_pred_test, residuos_test, alpha=0.6, color='orange', label='Teste')
        axes[1].axhline(y=0, color='r', linestyle='--')
        axes[1].set_title('Res√≠duos vs. Valores Previstos (Teste)')
        axes[1].set_xlabel('Valores Previstos')
        axes[1].set_ylabel('Res√≠duos')
        axes[1].legend()

    plt.tight_layout()
    st.pyplot(fig2)
    plt.close(fig2)


# 2. Otimiza√ß√£o do Uso de Recursos (com scipy.optimize) - Adaptada para Streamlit
def otimizacao_uso_recursos_avancado_streamlit(n_solo, p_solo, k_solo, area_ha,
                                               necessidades_cultura, custos, limites_aplicacao, preco_venda_un):
    """
    Calcula a quantidade √≥tima de √°gua e fertilizantes usando otimiza√ß√£o com scipy.optimize.
    Adaptada para Streamlit (usa st.write). Recebe valores diretos do app.
    """
    st.subheader("Resultado da Otimiza√ß√£o do Uso de Recursos")

    if area_ha <= 0:
        st.warning("√Årea inv√°lida para otimiza√ß√£o.")
        return
    if preco_venda_un <= 0:
         st.warning("Pre√ßo de venda deve ser maior que zero para otimiza√ß√£o de lucro.")
         return

    # Extrai necessidades m√≠nimas (kg/ha ou unidade/ha) - Vindo de inputs do Streamlit
    agua_necessaria_min_ha = necessidades_cultura.get('agua', 0)
    n_necessario_min_ha = necessidades_cultura.get('nitrogenio', 0)
    p_necessario_min_ha = necessidades_cultura.get('fosforo', 0)
    k_necessario_min_ha = necessidades_cultura.get('potassio', 0)

    # Extrai custos por unidade - Vindo de inputs do Streamlit
    custo_agua_un = custos.get('agua', 0)
    custo_fertilizante_n_un = custos.get('nitrogenio', 0)
    custo_fertilizante_p_un = custos.get('fosforo', 0)
    custo_fertilizante_k_un = custos.get('potassio', 0)

    # Extrai limites m√°ximos de aplica√ß√£o por hectare - Vindo de inputs do Streamlit
    max_agua_ha = limites_aplicacao.get('agua', 500)
    max_n_ha = limites_aplicacao.get('nitrogenio', 200)
    max_p_ha = limites_aplicacao.get('fosforo', 150)
    max_k_ha = limites_aplicacao.get('potassio', 250)


    def calcular_custo_total_ha(agua_aplicada_ha, n_aplicado_ha, p_aplicado_ha, k_aplicado_ha):
        return (agua_aplicada_ha * custo_agua_un +
                n_aplicado_ha * custo_fertilizante_n_un +
                p_aplicado_ha * custo_fertilizante_p_un +
                k_aplicado_ha * custo_fertilizante_k_un)

    # Define a Fun√ß√£o Objetivo (Para ser MINIMIZADA por scipy.optimize)
    # MINIMIZAMOS -Lucro = Custo Total - (Produ√ß√£o Total * Pre√ßo Venda)
    def objective_function(x):
        agua_aplicada_ha, n_aplicado_ha, p_aplicado_ha, k_aplicado_ha = x

        # Ensure non-negative application amounts within optimization
        agua_aplicada_ha = max(0, agua_aplicada_ha)
        n_aplicado_ha = max(0, n_aplicado_ha)
        p_aplicado_ha = max(0, p_aplicado_ha)
        k_aplicado_ha = max(0, k_aplicado_ha)


        n_total = n_solo + n_aplicado_ha
        p_total = p_solo + p_aplicado_ha
        k_total = k_solo + k_aplicado_ha
        agua_total = agua_aplicada_ha # Assuming 'agua_total' in model refers to applied water


        producao_ha_est = producao_por_ha_modelo(n_total, p_total, k_total, agua_total, necessidades_cultura)
        producao_total_area = producao_ha_est * area_ha

        custo_total_area = calcular_custo_total_ha(agua_aplicada_ha, n_aplicado_ha, p_aplicado_ha, k_aplicado_ha) * area_ha

        lucro = (producao_total_area * preco_venda_un) - custo_total_area

        return -lucro # Minimize negative lucro

    # --- Define as Restri√ß√µes (insumos totais >= m√≠nimo necess√°rio) ---
    # Constraints are defined such that constraint_value >= 0 for feasible solutions.
    def constraint_n(x):
        agua_aplicada_ha, n_aplicado_ha, p_aplicado_ha, k_aplicado_ha = x
        return (n_solo + n_aplicado_ha) - n_necessario_min_ha

    def constraint_p(x):
        agua_aplicada_ha, n_aplicado_ha, p_aplicado_ha, k_aplicado_ha = x
        return (p_solo + p_aplicado_ha) - p_necessario_min_ha

    def constraint_k(x):
        agua_aplicada_ha, n_aplicado_ha, p_aplicado_ha, k_aplicado_ha = x
        return (k_solo + k_aplicado_ha) - k_necessario_min_ha

    def constraint_agua(x):
        agua_aplicada_ha, n_aplicado_ha, p_aplicado_ha, k_aplicado_ha = x
        return agua_aplicada_ha - agua_necessaria_min_ha # Constraint on *applied* water >= minimum needed

    constraints = [
        {'type': 'ineq', 'fun': constraint_n},
        {'type': 'ineq', 'fun': constraint_p},
        {'type': 'ineq', 'fun': constraint_k},
        {'type': 'ineq', 'fun': constraint_agua},
    ]

    # --- Define os Limites (Bounds) para as vari√°veis (quantidades aplicadas por ha) ---
    bounds = [
        (0, max_agua_ha),      # agua_aplicada_ha
        (0, max_n_ha),         # n_aplicado_ha
        (0, max_p_ha),         # p_aplicado_ha
        (0, max_k_ha)          # k_aplicado_ha
    ]

    # --- Ponto Inicial da Otimiza√ß√£o ---
    x0 = [max(0, agua_necessaria_min_ha),
          max(0, n_necessario_min_ha - n_solo),
          max(0, p_necessario_min_ha - p_solo),
          max(0, k_necessario_min_ha - k_solo)]

    # Clip x0 to be within bounds
    x0 = [min(max(x0[0], bounds[0][0]), bounds[0][1]),
          min(max(x0[1], bounds[1][0]), bounds[1][1]),
          min(max(x0[2], bounds[2][0]), bounds[2][1]),
          min(max(x0[3], bounds[3][0]), bounds[3][1])]


    # --- Executa a Otimiza√ß√£o ---
    with st.spinner('Executando otimiza√ß√£o...'):
        try:
            result = minimize(objective_function, x0, method='SLSQP', bounds=bounds, constraints=constraints)
        except Exception as e:
            st.error(f"Ocorreu um erro durante a otimiza√ß√£o: {e}")
            return

    # --- Resultados ---
    st.subheader("Resultados Detalhados:")
    if result.success:
        agua_aplicada_ha_otima, n_aplicado_ha_otimo, p_aplicado_ha_otimo, k_aplicado_ha_otimo = result.x

        st.write("Status da Otimiza√ß√£o: **Sucesso**")
        st.write(f"Mensagem: {result.message}")
        st.write(f"Lucro M√°ximo Estimado: **{-result.fun:.2f}**") # Note: minimizing negative lucro

        st.subheader("Quantidades √ìtimas de Aplica√ß√£o (por hectare):")
        st.write(f"- √Ågua: {agua_aplicada_ha_otima:.2f} unidades/ha")
        st.write(f"- Nitrog√™nio: {n_aplicado_ha_otimo:.2f} kg/ha")
        st.write(f"- F√≥sforo: {p_aplicado_ha_otimo:.2f} kg/ha")
        st.write(f"- Pot√°ssio: {k_aplicado_ha_otimo:.2f} kg/ha")

        # Recalcular m√©tricas com os resultados √≥timos para exibi√ß√£o
        n_total_otimo = n_solo + n_aplicado_ha_otimo
        p_total_otimo = p_solo + p_aplicado_ha_otimo
        k_total_otimo = k_solo + k_aplicado_ha_otimo
        agua_total_otimo = agua_aplicada_ha_otima

        producao_ha_estimada_otima = producao_por_ha_modelo(n_total_otimo, p_total_otimo, k_total_otimo, agua_total_otimo, necessidades_cultura)
        producao_total_area_otima = producao_ha_estimada_otima * area_ha

        custo_total_area_otimo = calcular_custo_total_ha(agua_aplicada_ha_otima, n_aplicado_ha_otimo,
                                                          p_aplicado_ha_otimo, k_aplicado_ha_otimo) * area_ha
        lucro_otimo = (producao_total_area_otima * preco_venda_un) - custo_total_area_otimo

        st.subheader("N√≠veis e Estimativas com Aplica√ß√£o √ìtima:")
        st.write(f"- Nitrog√™nio Total (Solo + Aplicado) por ha: {n_total_otimo:.2f} kg/ha (M√≠nimo Necess√°rio: {n_necessario_min_ha:.2f})")
        st.write(f"- F√≥sforo Total (Solo + Aplicado) por ha: {p_total_otimo:.2f} kg/ha (M√≠nimo Necess√°rio: {p_necessario_min_ha:.2f})")
        st.write(f"- Pot√°ssio Total (Solo + Aplicado) por ha: {k_total_otimo:.2f} kg/ha (M√≠nimo Necess√°rio: {k_necessario_min_ha:.2f})")
        st.write(f"- √Ågua Aplicada por ha: {agua_aplicada_ha_otima:.2f} unidades/ha (M√≠nimo Necess√°rio: {agua_necessaria_min_ha:.2f})")


        st.write(f"\nProdu√ß√£o Estimada para a √Årea Total ({area_ha} ha): {producao_total_area_otima:.2f} unidades")
        st.write(f"Custo Total dos Insumos Aplicados para a √Årea: {custo_total_area_otimo:.2f}")
        st.write(f"Lucro Estimado para a √Årea: **{lucro_otimo:.2f}**")

        # Add download button
        optimization_summary = f"""
Otimiza√ß√£o de Recursos - Resumo
Status: Sucesso
Lucro M√°ximo Estimado: {lucro_otimo:.2f}

Quantidades √ìtimas de Aplica√ß√£o (por hectare):
- √Ågua: {agua_aplicada_ha_otima:.2f} unidades/ha
- Nitrog√™nio: {n_aplicado_ha_otimo:.2f} kg/ha
- F√≥sforo: {p_aplicado_ha_otimo:.2f} kg/ha
- Pot√°ssio: {k_aplicado_ha_otimo:.2f} kg/ha

N√≠veis e Estimativas com Aplica√ß√£o √ìtima:
- Nitrog√™nio Total (Solo + Aplicado) por ha: {n_total_otimo:.2f} kg/ha (M√≠nimo Necess√°rio: {n_necessario_min_ha:.2f})
- F√≥sforo Total (Solo + Aplicado) por ha: {p_total_otimo:.2f} kg/ha (M√≠nimo Necess√°rio: {p_necessario_min_ha:.2f})
- Pot√°ssio Total (Solo + Aplicado) por ha: {k_total_otimo:.2f} kg/ha (M√≠nimo Necess√°rio: {k_necessario_min_ha:.2f})
- √Ågua Aplicada por ha: {agua_aplicada_ha_otima:.2f} unidades/ha (M√≠nimo Necess√°rio: {agua_necessaria_min_ha:.2f})

Estimativas para a √Årea Total ({area_ha} ha):
- Produ√ß√£o Estimada: {producao_total_area_otima:.2f} unidades
- Custo Total dos Insumos Aplicados para a √Årea: {custo_total_area_otimo:.2f}
- Lucro Estimado para a √Årea: {lucro_otimo:.2f}

Par√¢metros Utilizados:
- √Årea: {area_ha} ha
- N√≠vel de N no Solo: {n_solo} kg/ha
- N√≠vel de P no Solo: {p_solo} kg/ha
- N√≠vel de K no Solo: {k_solo} kg/ha
- Necessidade M√≠nima de √Ågua: {agua_necessaria_min_ha} un/ha
- Necessidade M√≠nima de N: {n_necessario_min_ha} kg/ha
- Necessidade M√≠nima de P: {p_necessario_min_ha} kg/ha
- Necessidade M√≠nima de K: {k_necessario_min_ha} kg/ha
- Custo √Ågua: {custo_agua_un} /unidade
- Custo N: {custo_fertilizante_n_un} /kg
- Custo P: {custo_fertilizante_p_un} /kg
- Custo K: {custo_fertilizante_k_un} /kg
- Limite M√°x √Ågua: {max_agua_ha} un/ha
- Limite M√°x N: {max_n_ha} kg/ha
- Limite M√°x P: {max_p_ha} kg/ha
- Limite M√°x K: {max_k_ha} kg/ha
- Pre√ßo Venda: {preco_venda_un} /unidade produ√ß√£o
"""
        st.markdown(download_link(optimization_summary, 'otimizacao_agricola_resumo.txt', 'üì• Baixar Resumo da Otimiza√ß√£o (.txt)'), unsafe_allow_html=True)


    else:
        st.warning("\nResultado da Otimiza√ß√£o: **Falhou**")
        st.write(f"Status: {result.message}")
        st.write("N√£o foi poss√≠vel encontrar uma solu√ß√£o que satisfa√ßa as restri√ß√µes com os par√¢metros fornecidos.")
        st.info("Verifique se as necessidades m√≠nimas podem ser atendidas dentro dos limites m√°ximos de aplica√ß√£o, considerando os n√≠veis atuais do solo e os custos.")


# 3. Identifica√ß√£o de Pragas e Doen√ßas (Simula√ß√£o Estruturada) - Adaptada para Streamlit
def identificacao_pragas_doencas_simulacao_streamlit():
    """
    Simula a identifica√ß√£o de pragas ou doen√ßas.
    Adaptada para Streamlit (usa st.write). N√£o usa caminhos de arquivo reais nesta vers√£o do app.
    """
    st.subheader("Simula√ß√£o de Identifica√ß√£o de Pragas e Doen√ßas")

    st.markdown("""
    Esta se√ß√£o simula o que um sistema de identifica√ß√£o de pragas/doen√ßas baseado em imagem poderia fazer.
    **NENHUMA IMAGEM REAL √â PROCESSADA.** O resultado exibido √© aleat√≥rio para fins de demonstra√ß√£o conceitual.
    Um sistema real exigiria modelos de vis√£o computacional e upload/an√°lise de imagens de campo.
    """)

    # --- Simula√ß√£o de Predi√ß√£o ---
    pragas_doencas_simuladas = [
        'Ferrugem Asi√°tica (Simulado)',
        'Mancha Alvo (Simulado)',
        'O√≠dio (Simulado)',
        'Lagarta do Cartucho (Simulado)',
        'Doen√ßa F√∫ngica N√£o Identificada (Simulado)',
        'Ataque de Inseto (Simulado)',
        'Estresse H√≠drico (Simulado)',
        'Defici√™ncia Nutricional (Simulado)',
        'Saud√°vel (Simulado)'
        ]
    resultado_simulado = np.random.choice(pragas_doencas_simuladas)

    st.info(f"Analisando imagem (simulado)... Resultado: **{resultado_simulado}**")

    if 'Simulado' in resultado_simulado and 'Saud√°vel' not in resultado_simulado:
        st.warning("Aten√ß√£o: Poss√≠vel problema detectado!")
        st.write("Recomenda√ß√£o (Simulada): Avaliar as condi√ß√µes da lavoura para confirmar a presen√ßa do problema.")
        if 'Ferrugem' in resultado_simulado or 'Mancha' in resultado_simulado or 'O√≠dio' in resultado_simulado:
             st.write("Sugest√£o: Considerar aplica√ß√£o de fungicida, se confirmado.")
        elif 'Lagarta' in resultado_simulado or 'Inseto' in resultado_simulado:
             st.write("Sugest√£o: Considerar aplica√ß√£o de inseticida, se confirmado.")
        elif 'H√≠drico' in resultado_simulado:
             st.write("Sugest√£o: Verificar regime de irriga√ß√£o.")
        elif 'Nutricional' in resultado_simulado:
             st.write("Sugest√£o: Considerar an√°lise de solo/folha e aduba√ß√£o complementar.")
    else:
        st.success("A simula√ß√£o indica que a lavoura est√° Saud√°vel (Simulado).")


# 4. An√°lise de Mercado e Previs√£o de Pre√ßos (Prophet) - Adaptada para Streamlit
def analise_mercado_previsao_precos_streamlit(dados, produto, data_coluna, preco_coluna, periodos_futuro_dias=90):
     """
     Analisa dados de mercado e prev√™ os pre√ßos.
     Adaptada para Streamlit (usa st.write e st.pyplot).
     """
     st.subheader(f"Previs√£o de Pre√ßos de Mercado para: {produto} (Prophet)")
     colunas_necessarias = [data_coluna, preco_coluna, 'Cultura'] # 'Cultura' needed for filtering

     # Validate columns exist
     for coluna in colunas_necessarias:
         if coluna not in dados.columns:
             st.error(f"Erro: A coluna '{coluna}' √© necess√°ria para previs√£o de pre√ßos e n√£o foi encontrada no DataFrame.")
             return None # Retorna None em caso de erro

     dados_produto = dados[dados['Cultura'] == produto].copy()

     if dados_produto.empty:
         st.warning(f"N√£o h√° dados para o produto '{produto}' para previs√£o de pre√ßos.")
         return None

     # Prepara os dados para o Prophet
     df_prophet = dados_produto[[data_coluna, preco_coluna]].copy()
     df_prophet.columns = ['ds', 'y'] # Rename columns for Prophet

     # Garante que a coluna 'ds' √© datetime e remove NaT
     try:
         df_prophet['ds'] = pd.to_datetime(df_prophet['ds'], errors='coerce')
         df_prophet.dropna(subset=['ds'], inplace=True) # Remove rows where date conversion failed
     except Exception as e:
         st.error(f"Erro ao converter a coluna '{data_coluna}' para datetime: {e}")
         st.info("Verifique o formato da data na sua planilha. O Prophet espera formatos reconhec√≠veis (ex: YYYY-MM-DD). Linhas com datas inv√°lidas foram removidas.")
         return None

     # Agrega por data para ter um √∫nico ponto de pre√ßo por dia (m√©dia)
     df_prophet = df_prophet.groupby('ds')['y'].mean().reset_index()
     # Remove NaNs no pre√ßo ap√≥s agrega√ß√£o (se houver)
     df_prophet.dropna(subset=['y'], inplace=True)


     # Prophet precisa de pelo menos 2 pontos de dados distintos.
     if len(df_prophet) < 2:
          st.warning(f"Ap√≥s agrega√ß√£o por data, dados insuficientes para o produto '{produto}' para o modelo Prophet ({len(df_prophet)} pontos √∫nicos v√°lidos). S√£o necess√°rios pelo menos 2 pontos de data distintos com pre√ßos v√°lidos.")
          return None
     if len(df_prophet) < 10:
         st.info(f"Dados limitados ({len(df_prophet)} pontos √∫nicos v√°lidos) para o modelo Prophet. A previs√£o pode n√£o capturar sazonalidades complexas.")

     # Sort data by date
     df_prophet = df_prophet.sort_values('ds')

     # Cria e ajusta o modelo Prophet
     with st.spinner('Treinando modelo Prophet...'):
         modelo_prophet = Prophet(
             seasonality_mode='multiplicative',
             weekly_seasonality=True,
             daily_seasonality=False
         )
         # Optional: Add country holidays if relevant and data span years
         # try:
         #     modelo_prophet.add_country_holidays(country_name='BR') # Example for Brazil
         # except Exception as e:
         #     st.info(f"N√£o foi poss√≠vel adicionar feriados do pa√≠s (BR): {e}. Continue sem feriados.")


         try:
            modelo_prophet.fit(df_prophet)
         except Exception as e:
            st.error(f"Erro ao treinar o modelo Prophet: {e}")
            st.info("Verifique se h√° varia√ß√£o suficiente nos dados de pre√ßo ao longo do tempo.")
            return None

     st.success('Modelo Prophet treinado!')

     # Cria um DataFrame para previs√µes futuras
     future = modelo_prophet.make_future_dataframe(periods=periodos_futuro_dias)
     forecast = modelo_prophet.predict(future)

     # Imprime os resultados da previs√£o (primeiros e √∫ltimos dias da previs√£o)
     st.subheader(f"Previs√£o de pre√ßos de {produto} para os pr√≥ximos {periodos_futuro_dias} dias:")
     # Filtrar apenas as datas futuras
     last_historical_date = df_prophet['ds'].max()
     forecast_future = forecast[forecast['ds'] > last_historical_date].reset_index(drop=True)

     if not forecast_future.empty:
        st.write("Primeiros 10 dias previstos:")
        st.dataframe(forecast_future[['ds', 'yhat', 'yhat_lower', 'yhat_upper']].head(10))
        st.write("√öltimos 10 dias previstos:")
        st.dataframe(forecast_future[['ds', 'yhat', 'yhat_lower', 'yhat_upper']].tail(10))

        # Add download button for future forecast data
        csv_forecast = forecast_future[['ds', 'yhat', 'yhat_lower', 'yhat_upper']].to_csv(index=False)
        st.markdown(download_link(csv_forecast, f'{produto}_preco_previsto_prophet.csv', 'üì• Baixar Previs√£o Futura (.csv)'), unsafe_allow_html=True)

     else:
        st.info("N√£o h√° datas futuras no dataframe de previs√£o. Verifique o per√≠odo solicitado ou os dados de entrada.")


     # Plota a previs√£o
     st.subheader("Gr√°fico de Previs√£o:")
     fig1 = modelo_prophet.plot(forecast)
     plt.title(f'Previs√£o de Pre√ßos de {produto} com Prophet')
     plt.xlabel('Data')
     plt.ylabel(f'{preco_coluna}')
     st.pyplot(fig1)
     plt.close(fig1)

     # Plota os componentes da previs√£o
     st.subheader("Componentes da Previs√£o:")
     fig2 = modelo_prophet.plot_components(forecast)
     st.pyplot(fig2)
     plt.close(fig2)

     return forecast # Retorna o DataFrame de previs√£o


# 5. Visualiza√ß√£o de Dados e Pain√©is - Adaptada para Streamlit
def visualizacao_dados_painel_avancado_streamlit(dados, titulo_painel):
    """
    Cria visualiza√ß√µes de dados de exemplo para um painel interativo simulado.
    Adaptada para Streamlit (usa st.pyplot).
    """
    st.subheader(f"Visualiza√ß√µes Gerais dos Dados: {titulo_painel}")

    if dados.empty:
        st.warning("O DataFrame est√° vazio ap√≥s o pr√©-processamento. N√£o h√° dados para visualizar.")
        return

    # Exemplo: Distribui√ß√£o de Produ√ß√£o por Cultura (Boxplot)
    if 'Cultura' in dados.columns and 'Producao' in dados.columns:
        st.write("#### Distribui√ß√£o de Produ√ß√£o por Cultura")
        try:
            fig, ax = plt.subplots(figsize=(10, 6))
            sns.boxplot(x='Cultura', y='Producao', data=dados, ax=ax)
            ax.set_title('Distribui√ß√£o de Produ√ß√£o por Cultura')
            ax.set_xlabel('Cultura')
            ax.set_ylabel('Produ√ß√£o')
            plt.xticks(rotation=45, ha='right') # Rotate labels if many cultures
            plt.tight_layout() # Adjust layout
            st.pyplot(fig)
            plt.close(fig)
        except Exception as e:
            st.error(f"Erro ao gerar boxplot de Produ√ß√£o por Cultura: {e}")
            st.info("Verifique se as colunas 'Cultura' e 'Producao' existem e cont√™m dados v√°lidos.")

    else:
        st.info("Colunas 'Cultura' ou 'Producao' n√£o encontradas para o boxplot de produ√ß√£o.")

    # Exemplo: Rela√ß√£o entre Precipitacao e Producao (Scatter Plot com Hue por Cultura)
    if 'Precipitacao_Total' in dados.columns and 'Producao' in dados.columns and 'Cultura' in dados.columns:
        st.write("#### Rela√ß√£o entre Precipita√ß√£o e Produ√ß√£o por Cultura")
        try:
            fig, ax = plt.subplots(figsize=(10, 6))
            sns.scatterplot(x='Precipitacao_Total', y='Producao', hue='Cultura', data=dados, alpha=0.6, ax=ax)
            ax.set_title('Rela√ß√£o entre Precipita√ß√£o e Produ√ß√£o por Cultura')
            ax.set_xlabel('Precipita√ß√£o Total (mm)')
            ax.set_ylabel('Produ√ß√£o')
            plt.tight_layout()
            st.pyplot(fig)
            plt.close(fig)
        except Exception as e:
            st.error(f"Erro ao gerar scatter plot Precipita√ß√£o vs Produ√ß√£o: {e}")
            st.info("Verifique se as colunas 'Precipitacao_Total', 'Producao' e 'Cultura' existem e cont√™m dados num√©ricos/v√°lidos.")
    else:
         st.info("Colunas 'Precipitacao_Total', 'Producao' ou 'Cultura' n√£o encontradas para o scatter plot.")


    # Exemplo: M√©dia de N√≠veis de Solo por Tipo de Solo (Bar Plot)
    colunas_solo = ['N_Solo', 'P_Solo', 'K_Solo']
    if 'Tipo_Solo' in dados.columns and all(col in dados.columns for col in colunas_solo):
        st.write("#### M√©dia de N√≠veis de Nutrientes no Solo por Tipo de Solo")
        try:
            dados_solo_mean = dados.groupby('Tipo_Solo')[colunas_solo].mean().reset_index()
            dados_solo_melted = dados_solo_mean.melt('Tipo_Solo', var_name='Nutriente', value_name='M√©dia_N√≠vel')
            fig, ax = plt.subplots(figsize=(10, 6))
            sns.barplot(x='Tipo_Solo', y='M√©dia_N√≠vel', hue='Nutriente', data=dados_solo_melted, ax=ax)
            ax.set_title('M√©dia de N√≠veis de Nutrientes no Solo por Tipo de Solo')
            ax.set_xlabel('Tipo de Solo')
            ax.set_ylabel('M√©dia de N√≠vel (kg/ha)')
            plt.tight_layout()
            st.pyplot(fig)
            plt.close(fig)
        except Exception as e:
            st.error(f"Erro ao gerar bar plot Nutrientes por Solo: {e}")
            st.info("Verifique se as colunas 'Tipo_Solo', 'N_Solo', 'P_Solo' e 'K_Solo' existem e cont√™m dados v√°lidos.")

    else:
         st.info("Colunas 'Tipo_Solo', 'N_Solo', 'P_Solo' ou 'K_Solo' n√£o encontradas para o bar plot de nutrientes.")

    # Adicionar mais visualiza√ß√µes conforme necess√°rio...


# --- Layout Principal do Aplicativo Streamlit ---

st.set_page_config(layout="wide", page_title="Plataforma de An√°lise Agr√≠cola")

st.title("üå± Plataforma Interativa de An√°lise Agr√≠cola")

st.write("""
Esta plataforma oferece ferramentas para an√°lise de dados de safra, previs√£o de produ√ß√£o e pre√ßos,
al√©m de simula√ß√£o de otimiza√ß√£o de recursos e identifica√ß√£o de problemas.
""")

# --- Se√ß√£o de Como Usar / Requisitos de Dados ---
with st.expander("‚ÑπÔ∏è Como Usar e Requisitos de Dados"):
    st.markdown("""
    1.  **Fa√ßa Upload:** Comece fazendo upload do seu arquivo CSV com os dados agr√≠colas na se√ß√£o abaixo.
    2.  **Trate Dados Faltantes (Opcional):** Se o seu arquivo tiver valores faltantes, use a se√ß√£o de "Tratamento de Dados Faltantes" na barra lateral para decidir como lidar com eles.
    3.  **Selecione a An√°lise:** Use a barra lateral para escolher a an√°lise que deseja realizar (Visualiza√ß√µes, Previs√£o de Safra, Otimiza√ß√£o, Simula√ß√£o de Pragas/Doen√ßas, Previs√£o de Pre√ßos).
    4.  **Configure os Par√¢metros:** Em cada se√ß√£o de an√°lise, configure os par√¢metros necess√°rios (selecionar cultura, inserir valores de otimiza√ß√£o, etc.).
    5.  **Execute a An√°lise:** Clique no bot√£o para rodar a an√°lise e visualizar os resultados.

    **Estrutura de Dados Esperada (para todas as an√°lises funcionarem plenamente):**

    Seu arquivo CSV deve conter colunas relevantes para as an√°lises que voc√™ deseja rodar. Nomes de colunas comuns incluem:
    -   `Cultura` (Nome da cultura/produto)
    -   `Area_Colhida` (√Årea colhida em hectares)
    -   `Precipitacao_Total` (Precipita√ß√£o total durante o ciclo)
    -   `Temp_Media_Ciclo` (Temperatura m√©dia durante o ciclo)
    -   `Horas_Sol_Ciclo` (Horas de sol durante o ciclo)
    -   `Tipo_Solo` (Ex: Argiloso, Arenoso, etc.)
    -   `Manejo` (Ex: Convencional, Org√¢nico, etc.)
    -   `N_Solo`, `P_Solo`, `K_Solo` (N√≠veis de nutrientes no solo)
    -   `Producao` (Produ√ß√£o obtida)
    -   `Data_Ciclo` (Data de refer√™ncia para o ciclo, para previs√£o de pre√ßos)
    -   `Preco_Venda` (Pre√ßo de venda da produ√ß√£o, para previs√£o de pre√ßos)

    *O aplicativo tenta adaptar-se a nomes de colunas ligeiramente diferentes, mas seguir essa conven√ß√£o ou renomear suas colunas ajudar√° a garantir que todas as funcionalidades estejam dispon√≠veis.*
    """)


# --- Se√ß√£o de Upload de Dados ---
st.header("1. Upload dos Dados Agr√≠colas")

uploaded_file = st.file_uploader("Escolha um arquivo CSV (.csv) com seus dados", type="csv", key='csv_upload')

df_original = None # Inicializa df_original como None
df = None # df will be the processed dataframe

if uploaded_file is not None:
    try:
        # Use cache_data para evitar recarregar em cada intera√ß√£o se o arquivo for o mesmo
        @st.cache_data
        def load_and_clean_data(file):
            data = pd.read_csv(file)
            # Clean column names: remove leading/trailing spaces, special characters, replace spaces with underscore
            data.columns = data.columns.str.strip().str.replace(' ', '_').str.replace('[^A-Za-z0-9_]+', '', regex=True)
            # Ensure 'Cultura' is string type if it exists
            if 'Cultura' in data.columns:
                 data['Cultura'] = data['Cultura'].astype(str)
            return data

        df_original = load_and_clean_data(uploaded_file)
        df = df_original.copy() # Work on a copy to allow manipulation (like dropna)

        st.success("Arquivo carregado com sucesso!")
        st.write("Primeiras 5 linhas dos dados:")
        st.dataframe(df.head())

        st.write(f"O DataFrame cont√©m {df.shape[0]} linhas e {df.shape[1]} colunas.")

        # Exibe os nomes das colunas carregadas para refer√™ncia do usu√°rio
        st.write("Colunas carregadas (nomes limpos):")
        st.code(", ".join(df.columns.tolist()))

        # Optional: Show missing values
        st.write("Valores faltantes por coluna:")
        missing_values = df.isnull().sum()
        missing_values = missing_values[missing_values > 0]
        if not missing_values.empty:
            st.dataframe(missing_values.rename("Quantidade Faltante"))
        else:
            st.info("Nenhum valor faltante encontrado nos dados.")


    except pd.errors.EmptyDataError:
         st.error("O arquivo CSV est√° vazio.")
         df_original = None
         df = None
    except Exception as e:
        st.error(f"Ocorreu um erro ao carregar ou ler o arquivo: {e}")
        df_original = None
        df = None

# --- Se√ß√µes de An√°lise (Vis√≠vel apenas se dados forem carregados) ---

if df is not None and not df.empty:

    # Adiciona a barra lateral para sele√ß√£o de an√°lises e tratamento de dados
    st.sidebar.title("Navega√ß√£o e An√°lises")
    analise_selecionada = st.sidebar.radio(
        "Escolha a An√°lise:",
        ['Visualiza√ß√µes Gerais', 'Tratamento de Dados Faltantes', 'Previs√£o de Safra', 'Otimiza√ß√£o de Recursos', 'Simula√ß√£o Pragas/Doen√ßas', 'Previs√£o de Pre√ßos'],
        key='main_analysis_radio'
    )

    st.header(f"Se√ß√£o: {analise_selecionada}")

    # --- 1. Visualiza√ß√µes Gerais ---
    if analise_selecionada == 'Visualiza√ß√µes Gerais':
        visualizacao_dados_painel_avancado_streamlit(df, 'Dados Carregados')

    # --- 2. Tratamento de Dados Faltantes ---
    # Place this section *before* analyses that might require clean data
    elif analise_selecionada == 'Tratamento de Dados Faltantes':
         st.subheader("Tratamento de Dados Faltantes")
         st.markdown("""
         Seus dados cont√™m valores faltantes (NaN). Escolha um m√©todo para trat√°-los antes de executar as an√°lises.
         **Aten√ß√£o:** O tratamento ser√° aplicado ao DataFrame *dentro* deste aplicativo e afetar√° todas as an√°lises subsequentes.
         """)

         missing_values_current = df.isnull().sum()
         missing_values_current = missing_values_current[missing_values_current > 0]

         if missing_values_current.empty:
             st.success("N√£o h√° valores faltantes no DataFrame atual.")
         else:
             st.write("Colunas com valores faltantes:")
             st.dataframe(missing_values_current.rename("Quantidade Faltante"))

             method = st.radio(
                 "Escolha o m√©todo para tratar valores faltantes:",
                 ('Nenhum (Usar dados como est√£o)', 'Remover linhas com qualquer valor faltante', 'Remover colunas com valor faltante', 'Imputar com a M√©dia (Colunas Num√©ricas)', 'Imputar com a Mediana (Colunas Num√©ricas)', 'Imputar com a Moda (Colunas Categ√≥ricas/N√£o Num√©ricas)')
                 , key='missing_value_method'
             )

             df_processed = df.copy() # Create a copy to apply treatment

             if method == 'Remover linhas com qualquer valor faltante':
                 rows_before = len(df_processed)
                 df_processed.dropna(inplace=True)
                 rows_after = len(df_processed)
                 st.success(f"Removidas {rows_before - rows_after} linhas com valores faltantes.")
             elif method == 'Remover colunas com valor faltante':
                 cols_before = len(df_processed.columns)
                 df_processed.dropna(axis=1, inplace=True)
                 cols_after = len(df_processed.columns)
                 st.success(f"Removidas {cols_before - cols_after} colunas com valores faltantes.")
             elif 'Imputar com a' in method:
                 if 'M√©dia' in method or 'Mediana' in method:
                     # Impute numerical columns
                     numeric_cols_with_missing = df_processed.select_dtypes(include=np.number).columns[df_processed.select_dtypes(include=np.number).isnull().any()]
                     if not numeric_cols_with_missing.empty:
                         strategy = 'mean' if 'M√©dia' in method else 'median'
                         imputation_values = df_processed[numeric_cols_with_missing].agg(strategy)
                         df_processed[numeric_cols_with_missing] = df_processed[numeric_cols_with_missing].fillna(imputation_values)
                         st.success(f"Valores faltantes imputados com a {strategy} nas colunas num√©ricas: {', '.join(numeric_cols_with_missing)}")
                     else:
                         st.info("N√£o h√° colunas num√©ricas com valores faltantes para imputar com m√©dia/mediana.")
                 elif 'Moda' in method:
                     # Impute non-numerical/categorical columns
                     object_cols_with_missing = df_processed.select_dtypes(exclude=np.number).columns[df_processed.select_dtypes(exclude=np.number).isnull().any()]
                     if not object_cols_with_missing.empty:
                         for col in object_cols_with_missing:
                             mode_val = df_processed[col].mode()
                             if not mode_val.empty:
                                 df_processed[col] = df_processed[col].fillna(mode_val[0])
                                 st.success(f"Valores faltantes imputados com a moda na coluna '{col}'.")
                             else:
                                 st.warning(f"N√£o foi poss√≠vel encontrar a moda para imputa√ß√£o na coluna '{col}'.")
                     else:
                         st.info("N√£o h√° colunas n√£o num√©ricas com valores faltantes para imputar com a moda.")

             # Update the global df variable that other analyses will use
             df = df_processed.copy() # Use a copy to avoid potential streamlit state issues

             st.write("Status dos valores faltantes ap√≥s tratamento:")
             missing_values_after = df.isnull().sum()
             missing_values_after = missing_values_after[missing_values_after > 0]
             if not missing_values_after.empty:
                 st.dataframe(missing_values_after.rename("Quantidade Faltante Ap√≥s Tratamento"))
             else:
                 st.success("Todos os valores faltantes foram tratados.")

             st.write("Primeiras 5 linhas do DataFrame ap√≥s tratamento:")
             st.dataframe(df.head())


    # --- 3. Previs√£o de Safra (Gradient Boosting) ---
    elif analise_selecionada == 'Previs√£o de Safra':
        st.write("Esta an√°lise prev√™ a produ√ß√£o de safra com base em fatores ambientais e de manejo usando Machine Learning.")

        # Define default columns - check if they exist
        default_features_ml = ['Area_Colhida', 'Precipitacao_Total', 'Temp_Media_Ciclo', 'Horas_Sol_Ciclo', 'N_Solo', 'P_Solo', 'K_Solo']
        default_categorical_features_ml = ['Tipo_Solo', 'Manejo']
        default_target_ml = 'Producao'
        default_cultura_col = 'Cultura'

        # Check if 'Cultura' column exists for filtering
        if default_cultura_col not in df.columns:
             st.warning(f"Coluna '{default_cultura_col}' n√£o encontrada no DataFrame. A previs√£o de safra por cultura n√£o pode ser realizada.")
        elif default_target_ml not in df.columns:
             st.warning(f"Coluna target '{default_target_ml}' n√£o encontrada no DataFrame. A previs√£o de safra n√£o pode ser realizada.")
        else:
            culturas_disponiveis = df[default_cultura_col].unique().tolist()
            cultura_para_prever_safra = st.selectbox(
                "Selecione a Cultura para previs√£o de safra:",
                ['-- Selecione --'] + culturas_disponiveis,
                 key='safra_cultura_select'
            )

            # Get all available columns for feature selection
            all_cols = df.columns.tolist()
            # Exclude target and culture from selectable features
            possible_features = [col for col in all_cols if col not in [default_target_ml, default_cultura_col]]

            st.subheader("Configura√ß√£o do Modelo ML")

            # Feature Selection
            selected_features = st.multiselect(
                "Selecione as features num√©ricas para o modelo:",
                [f for f in possible_features if df[f].dtype in [np.number, 'int64', 'float64']],
                default=[f for f in default_features_ml if f in possible_features and df[f].dtype in [np.number, 'int64', 'float64']], # Pre-select defaults that exist and are numeric
                key='ml_num_features_select'
            )
            selected_categorical_features = st.multiselect(
                "Selecione as features categ√≥ricas para o modelo:",
                 [f for f in possible_features if df[f].dtype not in [np.number, 'int64', 'float64']],
                 default=[f for f in default_categorical_features_ml if f in possible_features and df[f].dtype not in [np.number, 'int64', 'float64']], # Pre-select defaults that exist and are non-numeric
                 key='ml_cat_features_select'
            )

            # Model Selection
            model_choice = st.selectbox(
                 "Escolha o Modelo de Machine Learning:",
                 ('Gradient Boosting Regressor', 'Random Forest Regressor', 'Linear Regression'),
                 key='ml_model_select'
            )


            if cultura_para_prever_safra != '-- Selecione --':
                if not selected_features and not selected_categorical_features:
                    st.warning("Por favor, selecione pelo menos uma feature (num√©rica ou categ√≥rica) para treinar o modelo.")
                else:
                    # Final check if selected features exist in the dataframe after potential missing value handling
                    all_selected = selected_features + selected_categorical_features
                    if not all(col in df.columns for col in all_selected):
                        missing_sel = [col for col in all_selected if col not in df.columns]
                        st.error(f"Uma ou mais features selecionadas n√£o existem no DataFrame ap√≥s o tratamento de dados: {', '.join(missing_sel)}. Por favor, revise sua sele√ß√£o ou o tratamento de dados.")
                    else:
                        if st.button(f"Executar Previs√£o de Safra para {cultura_para_prever_safra}", key='run_safra_button'):
                            analise_previsao_safras_avancado(df, cultura_para_prever_safra,
                                                            features=selected_features,
                                                            categorical_features=selected_categorical_features,
                                                            target=default_target_ml,
                                                            model_name=model_choice)
            else:
                 st.info("Selecione uma cultura para executar a an√°lise de safra.")


    # --- 4. Otimiza√ß√£o do Uso de Recursos ---
    elif analise_selecionada == 'Otimiza√ß√£o de Recursos':
        st.write("Esta se√ß√£o calcula as quantidades √≥timas de √°gua e fertilizantes a serem aplicados para maximizar o lucro, com base nos custos, necessidades da cultura e n√≠veis atuais do solo.")
        st.warning("O modelo de produ√ß√£o utilizado nesta otimiza√ß√£o √© **conceitual e simplificado**. Ele n√£o substitui modelos agron√¥micos calibrados com dados reais da sua regi√£o e cultura.")

        # Entradas do usu√°rio para otimiza√ß√£o
        st.subheader("Par√¢metros para Otimiza√ß√£o")
        area_otimizacao = st.number_input("√Årea para otimiza√ß√£o (hectares)", min_value=1.0, value=10.0, step=1.0, format="%.2f", key='area_otim')

        st.subheader("N√≠veis Atuais de Nutrientes no Solo (por hectare)")
        n_solo_otim = st.number_input("Nitrog√™nio (N) no solo (kg/ha)", min_value=0.0, value=50.0, step=1.0, format="%.2f", key='n_solo_otim')
        p_solo_otim = st.number_input("F√≥sforo (P) no solo (kg/ha)", min_value=0.0, value=30.0, step=1.0, format="%.2f", key='p_solo_otim')
        k_solo_otim = st.number_input("Pot√°ssio (K) no solo (kg/ha)", min_value=0.0, value=80.0, step=1.0, format="%.2f", key='k_solo_otim')

        st.subheader("Necessidades M√≠nimas da Cultura (por hectare)")
        st.info("Informe os n√≠veis M√çNIMOS de insumos totais (solo + aplicado) necess√°rios por hectare para que a cultura se desenvolva.")
        agua_nec_ha = st.number_input("Necessidade m√≠nima de √°gua (unidades/ha)", min_value=0.0, value=100.0, step=1.0, format="%.2f", key='agua_nec_ha')
        n_nec_ha = st.number_input("Necessidade m√≠nima de N (kg/ha)", min_value=0.0, value=120.0, step=1.0, format="%.2f", key='n_nec_ha')
        p_nec_ha = st.number_input("Necessidade m√≠nima de P (kg/ha)", min_value=0.0, value=60.0, step=1.0, format="%.2f", key='p_nec_ha')
        k_nec_ha = st.number_input("Necessidade m√≠nima de K (kg/ha)", min_value=0.0, value=150.0, step=1.0, format="%.2f", key='k_nec_ha')
        necessidades_cultura_otim = {'agua': agua_nec_ha, 'nitrogenio': n_nec_ha, 'fosforo': p_nec_ha, 'potassio': k_nec_ha}


        st.subheader("Custos por Unidade de Insumo")
        st.info("Informe o custo por unidade (ex: R$/unidade de √°gua, R$/kg de nutriente).")
        custo_agua = st.number_input("Custo da √°gua (por unidade)", min_value=0.0, value=0.5, step=0.01, format="%.2f", key='custo_agua')
        custo_n = st.number_input("Custo do fertilizante N (por kg)", min_value=0.0, value=2.5, step=0.01, format="%.2f", key='custo_n')
        custo_p = st.number_input("Custo do fertilizante P (por kg)", min_value=0.0, value=3.0, step=0.01, format="%.2f", key='custo_p')
        custo_k = st.number_input("Custo do fertilizante K (por kg)", min_value=0.0, value=2.0, step=0.01, format="%.2f", key='custo_k')
        custos_otim = {'agua': custo_agua, 'nitrogenio': custo_n, 'fosforo': custo_p, 'potassio': custo_k}

        st.subheader("Limites M√°ximos de Aplica√ß√£o (por hectare)")
        st.info("Defina os limites m√°ximos pr√°ticos de aplica√ß√£o por hectare para cada insumo.")
        max_agua = st.number_input("M√°x. √°gua (unidades/ha)", min_value=0.0, value=500.0, step=10.0, format="%.2f", key='max_agua')
        max_n = st.number_input("M√°x. N (kg/ha)", min_value=0.0, value=200.0, step=5.0, format="%.2f", key='max_n')
        max_p = st.number_input("M√°x. P (kg/ha)", min_value=0.0, value=150.0, step=5.0, format="%.2f", key='max_p')
        max_k = st.number_input("M√°x. K (kg/ha)", min_value=0.0, value=250.0, step=5.0, format="%.2f", key='max_k')
        limites_aplicacao_otim = {'agua': max_agua, 'nitrogenio': max_n, 'fosforo': max_p, 'potassio': max_k}

        st.subheader("Pre√ßo de Venda da Produ√ß√£o")
        st.info("Informe o pre√ßo esperado por unidade da produ√ß√£o (ex: R$/ton).")
        preco_venda_un = st.number_input("Pre√ßo de venda por unidade de produ√ß√£o", min_value=0.01, value=1500.0, step=10.0, format="%.2f", key='preco_venda_otim')


        if st.button("Executar Otimiza√ß√£o", key='run_otim_button'):
            otimizacao_uso_recursos_avancado_streamlit(n_solo_otim, p_solo_otim, k_solo_otim, area_otimizacao,
                                                        necessidades_cultura_otim, custos_otim, limites_aplicacao_otim, preco_venda_un)


    # --- 5. Simula√ß√£o Identifica√ß√£o Pragas/Doen√ßas ---
    elif analise_selecionada == 'Simula√ß√£o Pragas/Doen√ßas':
        st.write("Esta se√ß√£o demonstra o conceito de identifica√ß√£o de pragas ou doen√ßas via an√°lise de imagem.")
        identificacao_pragas_doencas_simulacao_streamlit()


    # --- 6. Previs√£o de Pre√ßos (Prophet) ---
    elif analise_selecionada == 'Previs√£o de Pre√ßos':
         st.write("Esta an√°lise utiliza o modelo Prophet para prever tend√™ncias de pre√ßos futuros com base no hist√≥rico.")

         # Get available columns for user selection
         available_cols = df.columns.tolist()
         # Try to pre-select common columns
         default_date_col = 'Data_Ciclo' if 'Data_Ciclo' in available_cols else (available_cols[0] if available_cols else None)
         default_price_col = 'Preco_Venda' if 'Preco_Venda' in available_cols else ('Producao' if 'Producao' in available_cols else (available_cols[1] if len(available_cols)>1 else None))
         default_cultura_col = 'Cultura' if 'Cultura' in available_cols else (available_cols[2] if len(available_cols)>2 else None)


         st.subheader("Configura√ß√£o da Previs√£o de Pre√ßos")
         st.info("Selecione as colunas que cont√™m a Data, o Pre√ßo e a identifica√ß√£o da Cultura/Produto.")

         date_col_price = st.selectbox("Selecione a coluna de Data:", available_cols, index=available_cols.index(default_date_col) if default_date_col in available_cols else 0, key='preco_date_col_select')
         price_col_price = st.selectbox("Selecione a coluna de Pre√ßo:", available_cols, index=available_cols.index(default_price_col) if default_price_col in available_cols else (1 if len(available_cols)>1 else 0), key='preco_price_col_select')

         # Check if 'Cultura' column is available for filtering
         if default_cultura_col not in df.columns:
             st.warning(f"Coluna '{default_cultura_col}' n√£o encontrada. A previs√£o de pre√ßos por produto/cultura n√£o √© poss√≠vel. Rode a an√°lise com todos os dados como um √∫nico produto.")
             # Option to treat all data as one product
             treat_as_single_product = st.checkbox("Tratar todos os dados como um √∫nico produto?", key='single_product_mode')
             if treat_as_single_product:
                  produto_para_prever_preco = "Todos os Produtos" # Use a placeholder
                  periodos_futuro = st.number_input("Quantos dias no futuro prever?", min_value=1, value=90, step=7, key='dias_futuro_preco')

                  # Validate selected columns before running
                  if date_col_price not in df.columns or price_col_price not in df.columns:
                       st.error(f"As colunas selecionadas ('{date_col_price}', '{price_col_price}') n√£o existem no DataFrame. Por favor, revise.")
                  else:
                       if st.button(f"Executar Previs√£o de Pre√ßos para {produto_para_prever_preco}", key='run_preco_button'):
                            # Create a dummy 'Cultura' column if treating as single product
                            df_single_product = df.copy()
                            df_single_product['Cultura'] = produto_para_prever_preco # Assign a constant value
                            analise_mercado_previsao_precos_streamlit(df_single_product, produto_para_prever_preco,
                                                                     data_coluna=date_col_price,
                                                                     preco_coluna=price_col_price,
                                                                     periodos_futuro_dias=periodos_futuro)

             else:
                  st.info("Selecione a op√ß√£o 'Tratar todos os dados como um √∫nico produto' se n√£o tiver uma coluna 'Cultura'.")


         else: # 'Cultura' column exists
             culturas_disponiveis_preco = df['Cultura'].unique().tolist()
             produto_para_prever_preco = st.selectbox(
                 "Selecione o Produto (Cultura) para previs√£o de pre√ßo:",
                 ['-- Selecione --'] + culturas_disponiveis_preco,
                 key='preco_produto_select'
             )
             periodos_futuro = st.number_input("Quantos dias no futuro prever?", min_value=1, value=90, step=7, key='dias_futuro_preco')

             if produto_para_prever_preco != '-- Selecione --':
                 # Validate selected columns before running
                 if date_col_price not in df.columns or price_col_price not in df.columns:
                      st.error(f"As colunas selecionadas ('{date_col_price}', '{price_col_price}') n√£o existem no DataFrame. Por favor, revise.")
                 else:
                      if st.button(f"Executar Previs√£o de Pre√ßos para {produto_para_prever_preco}", key='run_preco_button'):
                         analise_mercado_previsao_precos_streamlit(df, produto_para_prever_preco,
                                                                   data_coluna=date_col_price,
                                                                   preco_coluna=price_col_price,
                                                                   periodos_futuro_dias=periodos_futuro)
             else:
                 st.info("Selecione um produto para executar a previs√£o de pre√ßos.")

else:
    st.info("Aguardando o upload do arquivo CSV para exibir as op√ß√µes de an√°lise.")
    st.markdown("""
    Por favor, fa√ßa o upload do seu arquivo CSV na se√ß√£o acima para come√ßar.
    """)

# Footer opcional
st.sidebar.markdown("---")
st.sidebar.info("Desenvolvido como exemplo de aplica√ß√£o agr√≠cola com Python e Streamlit.")